<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>http2/3</title>
    <link href="/2022/03/02/network/http2-3/"/>
    <url>/2022/03/02/network/http2-3/</url>
    
    <content type="html"><![CDATA[<h2 id="http2-3"><a href="#http2-3" class="headerlink" title="http2/3"></a>http2/3</h2><h3 id="http1-1存在的问题，为什么要有http2"><a href="#http1-1存在的问题，为什么要有http2" class="headerlink" title="http1.1存在的问题，为什么要有http2"></a>http1.1存在的问题，为什么要有http2</h3><ol><li>在http1.1中是支持<em>持久连接</em>的，多个请求可以复用一个tcp连接，同时<em>管道pipelining</em>可以让多个请求在一次tcp连接中发送，但是因为一个管道中一次只能处理一个请求，所以存在排队问题，如此就会造成阻塞问题。</li><li>因为http连接是无状态的，所以每次请求头的内容都要大而全，所以经常会出现很多重复传输，例如user agent,Cookie,Accept等字段是固定且极有可能是完全重复的，所以导致很多带宽被浪费了</li><li>因为不需要支持https，所以http1.1的安全性是完全不够的</li></ol><h3 id="http2改进了什么"><a href="#http2改进了什么" class="headerlink" title="http2改进了什么"></a>http2改进了什么</h3><ol><li>二进制分帧层<br> 为了提升速度，http2将请求和响应都进行了分割，并且采用二进制编码，如此以来在传输中就不是传统的header+response的形式，而是一个个的小块二进制碎片。通过这种方式就可以实现http2中的多路复用了。</li><li>头部压缩HPACK<br> 通过对重复性很高的头部字段，通过在客户端和服务器端构建静态字典，通过索引表示重复的字段，同时利用哈夫曼编码来压缩数字和字符串。在第一次请求的时候只需要根据有的字典发送对应的索引即可，对于字典中没有的字段或者不同的，通过哈夫曼编码压缩后进行发送，然后双方动态更新字典，下次在进行连接时，如果没有变化就只需要发送一个索引就行了。</li><li>多路复用<br> 因为采用了二进制分帧，所以在http2中，可以把所有通信都放在一个连接中完成，双向数据流也没有限制，避免了多个慢启动的tcp连接，一次启动后就可以完成数据的交换，在交换数据时，有序发送流，在根据每个帧唯一的identify标签在服务器进行组合，大大解决了http1.1的阻塞问题</li><li>浏览器要求使用https<br> 因为要求使用https，虽然http2可以使用明文发送，但是大家都要求https，所以他的安全性要高很多。</li><li>服务器推送<br> 可以在请求的时候，不需要客户端要求，他会多推送内容给客户端，在配置端配置上push即可，但是因为server push很多时候和缓存冲突，已经被移除了标准。</li></ol><h3 id="http3-又怎么了"><a href="#http3-又怎么了" class="headerlink" title="http3 又怎么了"></a>http3 又怎么了</h3><ol><li>新的协议QUIC<br> 虽然分帧加多路复用可以大大缓解队头阻塞的问题，但是因为tcp他本身还是有序流，所以一旦发生丢包，tcp还是会进行重传</li></ol>]]></content>
    
    
    <categories>
      
      <category>http</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位操作集合</title>
    <link href="/2022/02/21/%E4%BD%8D%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88/"/>
    <url>/2022/02/21/%E4%BD%8D%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="取绝对值"><a href="#取绝对值" class="headerlink" title="取绝对值"></a>取绝对值</h3><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abs</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-keyword">return</span> (x^(x&gt;&gt;<span class="hljs-number">31</span>))-(x&gt;&gt;<span class="hljs-number">31</span>)&#125;</code></pre><h3 id="取下取整"><a href="#取下取整" class="headerlink" title="取下取整"></a>取下取整</h3><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ceil</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-keyword">return</span> x&gt;&gt;<span class="hljs-number">0</span>  <span class="hljs-comment">// x&lt;&lt;0</span>  <span class="hljs-comment">// ~x</span>&#125;</code></pre><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">floor</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-keyword">return</span> (x+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">0</span>&#125;</code></pre><h3 id="判断奇偶"><a href="#判断奇偶" class="headerlink" title="判断奇偶"></a>判断奇偶</h3><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isO</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-keyword">return</span> (x&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>&#125;<span class="hljs-comment">//true是奇数</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器和生成器</title>
    <link href="/2022/02/17/%20review/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2022/02/17/%20review/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h1><h2 id="迭代器是什么？"><a href="#迭代器是什么？" class="headerlink" title="迭代器是什么？"></a>迭代器是什么？</h2><p>&emsp;&emsp;在 javascript 中国呢，迭代器是一个对象。他定义了一个序列，并在终止时可能返回一个返回值。迭代器通过使用一个<code>next()</code>来实现<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol">可迭代协议</a>，对象可以自定义他们自己的迭代行为，比如在一个 for..of 中哪些值可以被便利到，在现有的类型中 array、Map、WeakMap 和 String 都有默认的迭代行为，是一个内置可迭代对象。但是 Object 就不行，他不是可迭代对的。<em>要可迭代，那么他必须实现一个<code>@@iterator</code>方法（一个无参数的函数，其返回值为一个符合迭代器协议的对象）</em><br>&emsp;&emsp;当迭代器创建之后，就可以通过重读的调用 next()来显式的迭代，当到结束位置后，<code>next()</code>返回<code>&#123;done:true&#125;</code>表示已经迭代完成了，也是消耗完了此次的迭代器，因为迭代一般就执行一次。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeIterator</span>(<span class="hljs-params">start = <span class="hljs-number">0</span>, end = <span class="hljs-number">100</span>, step = <span class="hljs-number">1</span></span>) </span>&#123;  <span class="hljs-keyword">let</span> iteratorCount = <span class="hljs-number">0</span>;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">if</span> (start &lt; end) &#123;          <span class="hljs-keyword">let</span> res = &#123; <span class="hljs-attr">value</span>: start, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;;          start += step;          iteratorCount++;          <span class="hljs-keyword">return</span> res;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: iteratorCount, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;      &#125;    &#125;  &#125;;&#125;<span class="hljs-keyword">let</span> iterator = makeIterator(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">let</span> target = iterator.next();<span class="hljs-keyword">while</span>(!target.done)&#123;    <span class="hljs-built_in">console</span>.log(target.value);    target = iterator.next();&#125;</code></pre><h2 id="生成器？"><a href="#生成器？" class="headerlink" title="生成器？"></a>生成器？</h2><p>&emsp;&emsp;生成器允许你定义一个包含自有迭代算法的函数， 同时它可以自动维护自己的状态。 生成器函数使用 <code>function*</code>语法编写。 最初调用时，生成器函数不执行任何代码，而是返回一种称为Generator的迭代器。 通过调用生成器的下一个方法消耗值时，Generator函数将执行，直到遇到yield关键字。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">makeRangeIterator</span>(<span class="hljs-params">start = <span class="hljs-number">0</span>, end = <span class="hljs-literal">Infinity</span>, step = <span class="hljs-number">1</span></span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; end; i += step) &#123;        <span class="hljs-keyword">yield</span> i;    &#125;&#125;<span class="hljs-keyword">var</span> a = makeRangeIterator(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>)a.next() <span class="hljs-comment">// &#123;value: 1, done: false&#125;</span>a.next() <span class="hljs-comment">// &#123;value: 3, done: false&#125;</span>a.next() <span class="hljs-comment">// &#123;value: 5, done: false&#125;</span>a.next() <span class="hljs-comment">// &#123;value: 7, done: false&#125;</span>a.next() <span class="hljs-comment">// &#123;value: 9, done: false&#125;</span>a.next() <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>迭代器和生成器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue组件通信</title>
    <link href="/2022/02/16/%20review/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <url>/2022/02/16/%20review/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="vue-组件通信"><a href="#vue-组件通信" class="headerlink" title="vue 组件通信"></a>vue 组件通信</h2><p>&emsp;&emsp;组件之间的作用域是独立的，但是我们很多时候都需要实现组件间的通信，父子双向通信，兄弟间通信，没有什么关系的组件间的通信。在组件通信方面总共有八种方法：</p><ol><li>props<br>最简单的一种方式，通过 props 来实现父组件向子组件传值，子组件通过 props 属性来接受父组件的参数</li></ol><pre><code class="hljs sqf"><span class="hljs-comment">//父组件</span>&lt;child <span class="hljs-built_in">name</span>=<span class="hljs-string">&#x27;hello&#x27;</span>&gt;&lt;/child&gt;<span class="hljs-comment">//子组件</span>&#123;    props:&#123;        <span class="hljs-built_in">name</span>:&#123;            <span class="hljs-built_in">type</span>:String,            <span class="hljs-keyword">default</span>:<span class="hljs-string">&#x27;nothing&#x27;</span>,            require:<span class="hljs-literal">true</span>        &#125;    &#125;,    <span class="hljs-comment">//...</span>&#125;</code></pre><ol start="2"><li>$emit $on<br>通过事件机制来实现 子组件向父组件传值，在子组件 emit 一个自定义事件，然后在父组件通过绑定监听器来接受数据</li></ol><pre><code class="hljs kotlin"><span class="hljs-comment">//父组件</span>&lt;chlid <span class="hljs-meta">@action</span>=<span class="hljs-string">&#x27;get&#x27;</span>&gt;&lt;/child&gt;<span class="hljs-keyword">get</span>(<span class="hljs-keyword">data</span>)&#123;    console.log(<span class="hljs-keyword">data</span>)   <span class="hljs-comment">//data</span>&#125;<span class="hljs-comment">//子组件</span><span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">&#x27;action&#x27;</span>,<span class="hljs-string">&#x27;data&#x27;</span>)；</code></pre><ol start="3"><li>ref<br>通过 ref 标签获取组件的标记来获得对象；</li></ol><pre><code class="hljs angelscript">&lt;Child <span class="hljs-built_in">ref</span>=<span class="hljs-string">&#x27;child&#x27;</span> /&gt;<span class="hljs-keyword">this</span>.$<span class="hljs-built_in">ref</span>s.child</code></pre><ol start="4"><li>EventBus<br>通过一个中央事件总线来作为载体进行兄弟组件传值；</li></ol><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bus</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">this</span>.callBackList=[];    &#125;    $on(name,<span class="hljs-function"><span class="hljs-keyword">function</span>)</span>&#123;        <span class="hljs-built_in">this</span>.callBackList[name] = <span class="hljs-built_in">this</span>.callBackList[name] || [];        <span class="hljs-built_in">this</span>.callBackList[name].push(<span class="hljs-function"><span class="hljs-keyword">function</span>)</span>;    &#125;    $emit(name,args)&#123;       <span class="hljs-built_in">this</span>.callBackList[name] &amp;&amp; <span class="hljs-built_in">this</span>.callBackList[name].forEach(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item(args));    &#125;&#125;<span class="hljs-comment">//main.js</span>Vue.prototype.$bus = <span class="hljs-keyword">new</span> Bus();<span class="hljs-comment">//或者直接使用vue</span>Vue.prototype.$bus = <span class="hljs-keyword">new</span> Vue();<span class="hljs-comment">//</span><span class="hljs-built_in">this</span>.$bus.$emit(<span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-built_in">this</span>.$bus.$on(<span class="hljs-string">&#x27;foo&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo callback&#x27;</span>);&#125;)</code></pre><ol start="5"><li><p>$parent $children<br>使用$parent和$children来访问父子实例来实现获取对应的数据，或者借助共同的父组件的$parent来实现小范围事物总线的功能</p><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$parent.on(<span class="hljs-string">&#x27;foo&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo&#x27;</span>)&#125;)<span class="hljs-built_in">this</span>.$parent.emit(<span class="hljs-string">&#x27;foo;);</span></code></pre></li><li><p>provide inject<br>借助provide和inject的方法来实现祖先后代传值</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">provide</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span>&#123;        <span class="hljs-attr">foo</span>:<span class="hljs-string">&#x27;foo&#x27;</span>    &#125;&#125;<span class="hljs-comment">//后代</span><span class="hljs-attr">inject</span>:[<span class="hljs-string">&#x27;foo&#x27;</span>]<span class="hljs-built_in">this</span>.foo  <span class="hljs-comment">//foo</span></code></pre><p>上面这种情况是无法实现响应式的，使用Vue.observable包裹要传递的变量可以实现响应式变化，vue3中不需要额外操作只需要<code>provide(&#39;name&#39;,name&#39;)</code>,后代中的<code>inject(&#39;name&#39;)</code>的值直接就是响应式的</p></li><li><p>$attrs $listeners<br>$attrs可以获取祖先作用域中没有被prop识别的属性（没有class和style），$listeners包含祖先作用域中的事件监听器（.native不包含）</p><pre><code class="hljs javascript"><span class="hljs-comment">//祖先</span>&lt;Child :a=<span class="hljs-string">&#x27;awd&#x27;</span> :bb=<span class="hljs-string">&#x27;bb&#x27;</span> @action=<span class="hljs-string">&#x27;doSomeThing&#x27;</span> /&gt;<span class="hljs-comment">//后代</span>...<span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.$attrs)    <span class="hljs-comment">//&#123;&quot;a&quot;:&quot;awd&quot;,&quot;bb&quot;:&quot;bb&quot;&#125;</span>    <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;action&#x27;</span>,<span class="hljs-string">&#x27;hello&#x27;</span>);   <span class="hljs-comment">//dosomething</span>&#125;</code></pre></li><li><p>vuex<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/202202171259545.png" title="vuex"></p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>父子通信：props/$emit, ref<br>兄弟通信：$bus，$parent<br>祖先后代：provide/inject,attrs<br>复杂传递：vuex</p>]]></content>
    
    
    <categories>
      
      <category>复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webWorker是个啥？</title>
    <link href="/2022/02/15/browser/webWorker%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/"/>
    <url>/2022/02/15/browser/webWorker%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是web-worker"><a href="#什么是web-worker" class="headerlink" title="什么是web worker"></a>什么是web worker</h2><p>&emsp;&emsp;总所周知，javascript是一门单线程的语言，我们是不能像操作系统一样同时跑多个程序或者任务，那么势必会因此出现运行中因为某些计算大的任务而导致后面的操作被停滞，虽然有事件循环机制eventloop来解决平时的冲突问题(可以看<a href="https://qiupo.github.io/2020/11/25/browser/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">事件循环</a>)，但是并不能解决根本问题。而web worker就是一种可以使操作并行执行的线程技术。通过web worker执行一些长时间运行的脚本或者处理计算密集型任务，同时又不会阻碍UI获取他脚本处理用户互动。<br>&emsp;&emsp;就这种功能来说的worker有两种，分别是专用 Worker 和 共享 Worker。专用worker就是只能被首次生成他的脚本使用，但是共享worker是可以被多个脚本使用的，他的上下文是sharedWorkerGlobalScop对象。就 Worker 来说，self 和 this 指的都是 Worker 的全局作用域。但是因为worker本身是独立的，所以worker只能操作javascript功能的子集。</p><ul><li>worker无法使用的部分<ul><li>DOM</li><li>window对象</li><li>document对象</li><li>parent对象</li></ul></li><li>worker可以使用的部分<ul><li>navigator对象</li><li>location对象（只读）</li><li>XMLHttpRequest</li><li>setTimeout()/clearTimeout()和setInterval()/clearInterval()</li><li>Appcache</li><li>使用importScript()导入外部脚本</li><li>生成其他web Worker</li></ul></li></ul><ol><li><p>专用 worker<br> 专用worker很好处理，直接生成然后使用postMessage进行通信即可。<br> <strong>main.js</strong></p> <pre><code class="hljs javascript"><span class="hljs-comment">//生成新的worker</span><span class="hljs-keyword">if</span>(!!<span class="hljs-built_in">window</span>.Worker)&#123;    <span class="hljs-keyword">let</span> myWorker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&#x27;worker.js&#x27;</span>);&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-comment">//...</span>&#125;<span class="hljs-comment">//发送消息</span>myWorker.postMessage([value1,value2])myWorker.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;    <span class="hljs-keyword">let</span> result = e.data;    <span class="hljs-comment">//处理</span>&#125;<span class="hljs-comment">//可手动关闭</span>myWorker.terminate();</code></pre><p> <strong>worker.js</strong></p> <pre><code class="hljs javascript">self.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-comment">//发送数据</span>    <span class="hljs-keyword">let</span> data = e.data;    <span class="hljs-comment">//操作</span>    self.postMessage(data);    &#125;, <span class="hljs-literal">false</span>);<span class="hljs-comment">//或者直接</span>onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;    <span class="hljs-keyword">let</span> data = e.data;    <span class="hljs-comment">//...</span>&#125;</code></pre></li><li><p>共享 worker<br> 共享 worker和专用worker很相似<br> main.js</p> <pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(!!<span class="hljs-built_in">window</span>.SharedWorker)&#123;    <span class="hljs-keyword">let</span> myWorker = <span class="hljs-keyword">new</span> SharedWorker(<span class="hljs-string">&#x27;worker.js&#x27;</span>)&#125;myWorker.port.postMessage([value1,value2]);myWorker.port.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;    <span class="hljs-keyword">let</span> result = e.data;    <span class="hljs-comment">//...</span>&#125;</code></pre><p> worker.js</p> <pre><code class="hljs javascript">onconnect = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;    <span class="hljs-keyword">let</span> port = e.port[<span class="hljs-number">0</span>];    port.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;        <span class="hljs-keyword">let</span> result = e.data;        <span class="hljs-comment">// ... </span>        port.postMessage(result);    &#125;&#125;</code></pre><p> 如果使用addEventListen方法，就需要使用</p><blockquote><p>port.start()  //worker线程<br> myWorker.port.start() //父线程</p></blockquote><p> 方法来调用</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>serviceWork离线缓存</title>
    <link href="/2022/02/15/browser/serviceWorker%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98/"/>
    <url>/2022/02/15/browser/serviceWorker%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是service-Worker"><a href="#什么是service-Worker" class="headerlink" title="什么是service Worker"></a>什么是service Worker</h2><p>&emsp;&emsp;Service Worker 是浏览器在后台独立于网页运行的脚本，它打开了通向不需要网页或用户交互的功能的大门。 现在，它们已包括如推送通知和后台同步等功能。 将来，Service Worker 将会支持如定期同步或地理围栏等其他功能。一般情况下我是考虑通过service Worker进行一些资源的缓存。<br>&emsp;&emsp;在使用service Worker的时候我们需要知道如何进行拦截网络请求和处理拦截到的网络请求。</p><ul><li>首先我们需要知道service Worker说到底他也是个worker，是web worker的一种。具备worker的特性，无法直接访问DOM（在worker中document是不存在的，但是我们可以间接的操作dom，因为javascript的单线程可以保证dom不会被多个操作方修改，不然发生资源抢占的情况太麻烦了，还得处理锁的问题，人家作者当初就没搞的这么复杂），并且通过postMessage来进行通信。</li><li>service worker安装启动也可以被中止，然后再次需要的时候就是重启的时候了，所有不能保证它里面保存的信息一直有效。不过我们可以通过self.IndexedDB来存储JSON之类的数据，通过Cache接口来缓存url可寻址资源。<pre><code class="hljs javascript">event.waitUntil(    caches.open(<span class="hljs-string">&#x27;v1&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cache</span>) </span>&#123;      <span class="hljs-keyword">return</span> cache.addAll([        <span class="hljs-string">&#x27;./index.html&#x27;</span>,        <span class="hljs-string">&#x27;./img/1.jpg&#x27;</span>        <span class="hljs-comment">//...</span>        ]);    &#125;)  );<span class="hljs-comment">//...</span>self.addEventListener(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;  event.respondWith(caches.match(event.request).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;    <span class="hljs-keyword">if</span> (response !== <span class="hljs-literal">undefined</span>) &#123;        <span class="hljs-comment">//如果能访问直接走正常的请求</span>      <span class="hljs-keyword">return</span> response;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//不能就走cache里存好的资源</span>      <span class="hljs-keyword">return</span> fetch(event.request).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;        <span class="hljs-comment">// response 只能使用一次，所以我们先创建个拷贝，把cache的资源放进去后在返回</span>        <span class="hljs-keyword">let</span> responseClone = response.clone();        caches.open(<span class="hljs-string">&#x27;v1&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cache</span>) </span>&#123;          cache.put(event.request, responseClone);        &#125;);        <span class="hljs-keyword">return</span> response;      &#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> caches.match(<span class="hljs-string">&#x27;./error.jpg&#x27;</span>);      &#125;);    &#125;  &#125;));&#125;);</code></pre></li></ul><h2 id="service-worker的生命周期"><a href="#service-worker的生命周期" class="headerlink" title="service worker的生命周期"></a>service worker的生命周期</h2><p>&emsp;&emsp;因为service worker会对请求进行拦截，为了安全考虑，一定需要使用HTTPS来保障请求的安全性（本地调试是可以通过localhost使用的）。下面是service worker的生命周期，我们在使用时就是通过这些生命周期的钩子进行一些操作。<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/202202151533004.png" title="service worker生命周期"><br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/202202151534335.png" title="支持的事件"></p><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><ol><li><p>首先我们需要注册service worker，在页面中注册</p><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator)&#123;    widnow.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>,<span class="hljs-function"><span class="hljs-title">funciton</span>(<span class="hljs-params"></span>)</span>&#123;        navigator.serviceWorker.register(<span class="hljs-string">&#x27;/sw.js&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">registration</span>) </span>&#123;            <span class="hljs-comment">// 注册成功</span>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ServiceWorker registration successful with scope: &#x27;</span>, registration.scope);        &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;            <span class="hljs-comment">// 注册失败</span>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ServiceWorker registration failed: &#x27;</span>, err);        &#125;);    &#125;)&#125;</code></pre><p>在注册时的sw文件的位置代表着service worker的作用位置，如果是位于<code>/user/sw.js</code>，那么service worker上就只能看到以<code>/user</code>开头的网址，所以我们可以通过针对不同内容进行不同的service worker操作，也可以直接作用在根网域实现全面的拦截。</p></li><li><p>isntall<br>然后进入到我们的sw文件中，此时我们可以在install的生命周期中做一些操作，比如初始化indexedDB的操作。</p><pre><code class="hljs javascript">self.addEventListener(<span class="hljs-string">&#x27;install&#x27;</span>,<span class="hljs-function"><span class="hljs-title">funciton</span>(<span class="hljs-params">event</span>)</span>&#123;    <span class="hljs-comment">//我们的操作可以决定要缓存哪些文件</span>    event.waitUntil(        caches.open(<span class="hljs-string">&#x27;v1&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cache</span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;cache打开&#x27;</span>);            <span class="hljs-keyword">return</span> cache.addAll([                <span class="hljs-string">&#x27;./index.html&#x27;</span>,                <span class="hljs-string">&#x27;./img/1.jpg&#x27;</span>                <span class="hljs-comment">//...</span>            ]);        &#125;)    )&#125;)</code></pre></li><li><p>更新service worker<br>在有新的service worker时，我们需要摆除旧worker，然后加载新的worker。</p></li></ol><ul><li>在导航到网站时，新的worker会被下载并且启动从而触发install事件</li><li>但是因为现在这个页面已经被旧worker控制了，所以新的worker会进入waiting状态。（如果使用self.skipWaiting可以不用等待当前控制页面的worker关闭，从而跳过等待状态，然后让新的worker跳到activating状态）</li><li>如果旧的worker被中止了（页面关闭了），新的worker就会获得控制权了</li><li>新的worker触发activate事件</li></ul><h2 id="借助workbox"><a href="#借助workbox" class="headerlink" title="借助workbox"></a>借助workbox</h2><p>&emsp;&emsp;如果我们自己写sw的过滤规则那真的是有点麻烦，好在已经有人已经写好了一组库帮助我们进行service worker的使用。<a href="https://developers.google.com/web/tools/workbox/guides/get-started">workbox</a>,可以帮助我们进行编写和管理service worker来进行缓存任务。</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入url到出现内容的流程</title>
    <link href="/2022/02/11/browser/%E8%BE%93%E5%85%A5url%E5%88%B0%E5%87%BA%E7%8E%B0%E5%86%85%E5%AE%B9%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/02/11/browser/%E8%BE%93%E5%85%A5url%E5%88%B0%E5%87%BA%E7%8E%B0%E5%86%85%E5%AE%B9%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器点击链接后的流程"><a href="#浏览器点击链接后的流程" class="headerlink" title="浏览器点击链接后的流程"></a>浏览器点击链接后的流程</h2><p>处理流程：<br>1、输入网址并回车<br>2、通过DNS解析域名，得到地址给浏览器<br>3、浏览器发送HTTP请求<br>4、服务器处理请求<br>5、服务器返回HTML响应<br>6、浏览器处理HTML页面<br>7、继续请求其他资源<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201124110413.png"></p><p>&emsp;&emsp;计算器IO接收到输入的值，并且浏览器接收到指令，从此开始我们的冲浪之旅。  </p><ol><li>解析url<br>浏览器先要弄懂用户输入的东西是个什么玩意，才能进行接下来的操作<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/202202111049837.jpeg" title="绝对url格式"><br>上图还是很好理解的，那么当浏览器理解了用户输入了什么之后，他就迈出第一步了：</li></ol>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>首屏优化</title>
    <link href="/2022/02/10/%20review/%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96/"/>
    <url>/2022/02/10/%20review/%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="首屏优化"><a href="#首屏优化" class="headerlink" title="首屏优化"></a>首屏优化</h3><p>&emsp;&emsp;首先祭出神图，来源是 <a href="https://proxy.qiupo.workers.dev/?https://www.w3.org/TR/navigation-timing/#sec-window.performance-attribute">w3.org</a><br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/202202111123837.png" title="Processing Model"></p><h2 id="什么是首屏"><a href="#什么是首屏" class="headerlink" title="什么是首屏"></a>什么是首屏</h2><p>什么是首屏呢？<br>&emsp;&emsp;显而易见，这就是打开网址后最先出现在用户面前的页面，在这个首次展现的过程中，我们会遇到很多问题，比如说：输入网址后回车，页面是白色的，需要等待很久才能出来内容。<br>&emsp;&emsp;那么为了解决这个问题，我们必须了解浏览器首屏的时候都做了什么事情？其实这里面涉及到很多的内容，因为我个人认为首屏时间其实包含用户从输入好网址后回车开始页面出现内容为止这段时间，那么这段时间发生了什么呢？</p><h1 id="输入url到页面出来中发生了什么？"><a href="#输入url到页面出来中发生了什么？" class="headerlink" title="输入url到页面出来中发生了什么？"></a>输入url到页面出来中发生了什么？</h1><p>&emsp;&emsp;我们只讨论其中比较重要的部分，那么显而易见的可以分成以下几个部分(<a href="https://qiupo.github.io/2022/02/11/browser/%E8%BE%93%E5%85%A5url%E5%88%B0%E5%87%BA%E7%8E%B0%E5%86%85%E5%AE%B9%E7%9A%84%E6%B5%81%E7%A8%8B/">详情可以看另一篇</a>)：</p><ul><li><p>url解析，dns 查询</p></li><li><p>连接请求</p></li><li><p>响应并接受资源</p></li><li><p>页面渲染</p><p>  在这里我们主要看看页面渲染过程中的各个性能指标是什么。</p></li></ul><h2 id="性能指标有哪些"><a href="#性能指标有哪些" class="headerlink" title="性能指标有哪些"></a>性能指标有哪些</h2><p>&emsp;&emsp;我们通过Chrome的控制台输入performance就可以输出performance.timing的值，从这里我们可以很清晰的看到神图中各个部分的执行时间。<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/202202101748527.png" title="performance返回值"><br>从<a href="https://proxy.qiupo.workers.dev/?https://www.w3.org/TR/navigation-timing/#sec-window.performance-attribute">w3.org</a> 中可以读到这些参数的具体作用和使用流程：</p><ol><li><em>If the navigation is aborted for any of the following reasons, abort these steps without changing the attributes in window.performance.timing and window.performance.navigation.</em><br>如果导航由于下列任何原因而中止，则中止这些步骤，但不要更改window.performance.timing和window.performance.navigation中的属性。<ul><li><em>The navigation is aborted due to the sandboxed navigation browsing context flag or the sandboxed top-level navigation browsing context flag, or a preexist attempt to navigate the browsing context.</em><br>由于沙箱导航浏览上下文标志或沙箱顶级导航浏览上下文标志，或预先存在的导航浏览上下文的尝试，导航将中止。</li><li><em>The navigation is caused by fragment identifiers within the page.</em><br>导航是由页面内的片段标识符引起的。</li><li><em>The new resource is to be handled by some sort of inline content.</em><br>新资源将由某种内联内容处理。</li><li><em>The new resource is to be handled using a mechanism that does not affect the browsing context.</em><br>新资源将使用一种不影响浏览上下文的机制来处理。</li><li><em>The user refuses to allow the document to be unloaded.</em><br>用户拒绝卸载文档</li></ul></li><li><em>Immediately after the user agent prompts to unload the previous document, record the current time as <font color=red>navigationStart</font>.</em><br>在用户代理提示卸载前一个文档之后，立即将当前时间记录为navigationStart。</li><li><em>Record the current navigation type in window.performance.navigation.type if it has not been set:</em><br>如果还没有设置，则在window.performance.navigation.type中记录当前的导航类型<ul><li><em>If the navigation was started by clicking on a link, or entering the URL in the user agent’s address bar, or form submission, or initializing through a script operation other than the location.reload() method, let the navigation type be TYPE_NAVIGATE.</em><br>如果导航是通过单击链接，或在用户代理的地址栏中输入URL，或表单提交，或通过location.reload()方法以外的脚本操作进行初始化来启动的，那么导航类型应该是TYPE_NAVIGATE</li><li><em>If the navigation was started either as a result of a meta refresh, or the location.reload() method, or other equivalent actions, let the navigation type be TYPE_RELOAD.</em><br>如果导航是元刷新的结果，或者location.reload()方法，或者其他等效操作的结果，那么就让导航类型为TYPE_RELOAD。</li><li><em>If the navigation was started as a result of history traversal, let the navigation type be TYPE_BACK_FORWARD.</em><br>如果导航是历史遍历的结果，请将导航类型设置为TYPE_BACK_FORWARD。</li><li><em>Otherwise, let the navigation type be TYPE_RESERVED.</em><br>否则，让导航类型为TYPE_RESERVED。</li></ul></li></ol><p><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/202202141342968.png" title="navigation Type"></p><p> The PerformanceNavigation interface<br> <pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> PerformanceNavigation &#123;  <span class="hljs-keyword">const</span> unsigned short TYPE_NAVIGATE = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> unsigned short TYPE_RELOAD = <span class="hljs-number">1</span>;  <span class="hljs-keyword">const</span> unsigned short TYPE_BACK_FORWARD = <span class="hljs-number">2</span>;  <span class="hljs-keyword">const</span> unsigned short TYPE_RESERVED = <span class="hljs-number">255</span>;  <span class="hljs-keyword">readonly</span> attribute unsigned short <span class="hljs-keyword">type</span>;  <span class="hljs-keyword">readonly</span> attribute unsigned short redirectCount;&#125;;</code></pre></p><ul><li><em>TYPE_NAVIGATE</em><ul><li><em>Navigation started by clicking on a link, or entering the URL in the user agent’s address bar, or form submission, or initializing through a script operation other than the ones used by TYPE_RELOAD and TYPE_BACK_FORWARD as listed below.</em><br>导航开始于单击链接，或在用户代理的地址栏中输入URL，或表单提交，或通过脚本操作(TYPE_RELOAD和TYPE_BACK_FORWARD所使用的操作除外)进行初始化，如下所示。</li></ul></li><li><em>TYPE_RELOAD</em><ul><li><em>Navigation through the reload operation or the location.reload() method.</em><br>通过重载操作或location.reload()方法进行导航。</li></ul></li><li><em>TYPE_BACK_FORWARD</em><ul><li><em>Navigation through a history traversal operation.</em><br>通过历史记录遍历操作进行导航。</li></ul></li><li>TYPE_RESERVED<ul><li><em>Any navigation types not defined by values above.</em><br>没有由上面的值定义的任何导航类型</li></ul></li></ul><ol start="4"><li><em>If the current document and the previous document are from different origins, set both <font color=red>unloadEventStart</font> and <font color=red>unloadEventEnd</font> to 0 then go to step 6. Otherwise, record <font color=red>unloadEventStart</font> as the time immediately before the unload event.</em><br>如果当前文档和前一个文档来自不同的起源，将unlodeventstart和unlodeventend都设置为0，然后执行步骤6。否则，将unloaddeventstart记录为立即发生卸载事件之前的时间。</li><li><em>Immediately after the unload event is completed, record the current time as <font color=red>unloadEventEnd</font>.</em><br>在卸载事件完成后，立即将当前时间记录为unloaddeventend</li><li><em>If the new resource is to be fetched using HTTP GET or equivalent, immediately before a user agent checks with the relevant application caches, record the current time as <font color=red>fetchStart</font>. Otherwise, immediately before a user agent starts the fetching process, record the current time as <font color=red>fetchStart</font>.</em><br>如果要使用HTTP GET或同等的方法获取新资源，则在用户代理检查相关应用程序缓存之前，将当前时间记录为fetchStart。否则，在用户代理开始抓取过程之前，将当前时间记录为fetchStart。</li><li><em>Let <font color=red>domainLookupStart</font>, <font color=red>domainLookupEnd</font>, <font color=red>connectStart</font> and <font color=red>connectEnd</font> be the same value as <font color=red>fetchStart</font>.</em><br>让domainLookupStart、domainLookupEnd、connectStart和connectEnd与fetchStart相同。</li><li><em>If the resource is fetched from the relevant application cache or local resources, including the HTTP cache, go to step 13.</em><br>如果是从相关应用缓存或本地资源(包括HTTP缓存)获取，请执行步骤13</li><li><em>If no domain lookup is required, go to step 11. Otherwise, immediately before a user agent starts the domain name lookup, record the time as <font color=red>domainLookupStart</font>.</em><br>如果不需要进行域解析，执行步骤11。否则，在用户代理开始域名查找之前，将时间记录为domainLookupStart。</li><li><em>Record the time as <font color=red>domainLookupEnd</font> immediately after the domain name lookup is successfully done. A user agent may need multiple retries before that. If the domain lookup fails, abort the rest of the steps.</em><br>域名查找成功后，立即将时间记录为domainLookupEnd。在此之前，用户代理可能需要多次重试。如果域查找失败，则中止其余步骤。</li><li><em>If a persistent transport connection is used to fetch the resource, let <font color=red>connectStart</font> and <font color=red>connectEnd</font> be the same value of <font color=red>domainLookupEnd</font>. Otherwise, record the time as <font color=red>connectStart</font> immediately before initiating the connection to the server and record the time as <font color=red>connectEnd</font> immediately after the connection to the server or the proxy is established. A user agent may need multiple retries before this time. If a connection can not be established, abort the rest of the steps.</em><br>如果使用一个持久传输连接来获取资源，则让connectStart和connectEnd的值与domainLookupEnd相同。否则，在与服务器建立连接之前，将时间记录为connectStart;在与服务器或代理建立连接之后，将时间记录为connectStart。在此之前，用户代理可能需要多次重试。如果不能建立连接，则中止其余步骤。</li><li><em>In step 11, a user agent should also carry out these additional steps if it supports the <font color=red>secureConnectionStart</font> attribute:</em><br>在第11步中，如果用户代理支持secureConnectionStart属性，它也应该执行这些额外的步骤:<ul><li><em>If the scheme of the current document is HTTPS, the user agent must record the time as <font color=red>secureConnectionStart</font> immediately before the handshake process to secure the connection.</em><br>如果当前文档的方案是HTTPS，则用户代理必须在握手之前将时间记录为secureConnectionStart，以确保连接安全。</li><li><em>If the scheme of the current document is not HTTPS, the user agent must set the value of <font color=red>secureConnectionStart</font> to 0.</em><br>如果当前文档的方案不是HTTPS，则用户代理必须将secureConnectionStart的值设置为0。</li></ul></li><li><em>Immediately before a user agent starts sending request for the document, record the current time as <font color=red>requestStart</font>.</em><br>在用户代理开始发送文档请求之前，将当前时间记录为requestStart。</li><li><em>Record the time as <font color=red>responseStart</font> immediately after the user agent receives the first byte of the response.</em><br>在用户代理接收到响应的第一个字节后，立即将时间记录为responseStart。</li><li><em>Record the time as <font color=red>responseEnd</font> immediately after receiving the last byte of the response.</em><br>在接收到响应的最后一个字节后，立即将时间记录为responseEnd。</li><li><em>If the fetched resource results in an HTTP redirect or equivalent, then</em><br>如果获取的资源导致HTTP重定向或等效的结果，那么<ul><li><em>if the current document and the document that is redirected to are not from the same origin, set <font color=red>redirectStart</font>, <font color=red>redirectEnd</font>, <font color=red>unloadEventStart</font>, <font color=red>unloadEventEnd</font> and redirectCount to 0. Then, return to step 6 with the new resource.</em><br>如果当前文档和被重定向到的文档不是来自同一个来源，则设置redirectStart、redirectEnd、unlodeventstart、unlodeventend和redirectCount为0。然后，使用新资源返回到步骤6。</li><li><em>if there is previous redirect involving documents that are not from the same origin, set <font color=red>redirectStart</font>, <font color=red>redirectEnd</font>, <font color=red>unloadEventStart</font>, <font color=red>unloadEventStart</font> and redirectCount to 0. Then, return to step 6 with the new resource.</em><br>如果先前的重定向涉及到来自不同来源的文档，则将redirectStart、redirectEnd、unlodeventstart、unlodeventstart和redirectCount设置为0。然后，使用新资源返回到步骤6。</li><li><em>Increment redirectCount by 1.</em><br>redirectCount增量1。</li><li><em>If the value of <font color=red>redirectStart</font> is 0, let it be the value of <font color=red>fetchStart</font>.</em><br>如果redirectStart的值为0，则设为fetchStart的值。</li><li><em>Let <font color=red>redirectEnd</font> be the value of <font color=red>responseEnd</font>.</em><br>让redirectEnd作为responseEnd的值。</li><li><em>Set all the attributes in window.performance.timing to 0 except <font color=red>navigationStart</font>, redirectStart, redirectEnd, unloadEventStart and unloadEventEnd.</em><br>将window.performance.timing中除navigationStart、redirectStart、redirectEnd、unlodeventstart和unlodeventend之外的所有属性设置为0。</li><li><em>Return to step 6 with the new resource.</em><br>使用新资源返回到步骤6。</li></ul></li><li><em>Record the time as <font color=red>domLoading</font> immediately before the user agent sets the current document readiness to “loading”.</em><br>在用户代理将当前文档准备状态设置为“loading”之前，将时间记录为domLoading。</li><li><em>Record the time as <font color=red>domInteractive</font> immediately before the user agent sets the current document readiness to “interactive”.</em><br>在用户代理将当前文档准备状态设置为“交互式”之前，将时间记录为domInteractive。</li><li><em>Record the time as <font color=red>domContentLoadedEventStart</font> immediately before the user agent fires the DOMContentLoaded event at the document.</em><br>在用户代理在文档中触发DOMContentLoaded事件之前，将时间记录为domContentLoadedEventStart。</li><li><em>Record the time as <font color=red>domContentLoadedEventEnd</font> immediately after the DOMContentLoaded event completes.</em><br>在DOMContentLoaded事件完成后，将时间记录为domContentLoadedEventEnd。</li><li><em>Record the time as <font color=red>domComplete</font> immediately before the user agent sets the current document readiness to “complete”.</em><br>在用户代理将当前文档准备就绪状态设置为“完成”之前，将时间记录为domComplete。</li><li><em>Record the time as <font color=red>loadEventStart</font> immediately before the user agent fires the load event.</em><br>在用户代理触发load事件之前，将时间记录为loaddeventstart。</li><li><em>Record the time as <font color=red>loadEventEnd</font> immediately after the user agent completes the load event.</em><br>在用户代理完成load事件后，立即将时间记录为loaddeventend。</li></ol><p>&emsp;&emsp;从上面的官方文字我们可以看出来timing指标中主要涉及三个方面：</p><ul><li>网络请求时间<br>  redirectEnd redirectStart domainLookUpEnd domainLookUpStart connectEnd connectStart</li><li>请求响应时间<br>  requestStart responseEnd responseStart </li><li>解析渲染时间<br>  domLoading domInteractive domContentLoadedEventStart domContentLoadedEventEnd domComplete    </li></ul><p>&emsp;&emsp;其中可以算出一些常用的性能指标：</p><ul><li>DNS查询耗时 = domainLookupEnd - domainLookupStart</li><li>TCP链接耗时 = connectEnd - connectStart</li><li>request请求耗时 = responseEnd - responseStart</li><li>解析dom树耗时 = domComplete - domInteractive</li><li>domready时间 = domContentLoadedEventEnd - fetchStart</li><li>首屏渲染时间、首次有内容渲染时间 performance.getEntriesByType(‘paint’) <a href="https://w3c.github.io/paint-timing/">https://w3c.github.io/paint-timing/</a></li><li>onload时间 = loadEventEnd - fetchStart<h2 id="可以做什么来优化"><a href="#可以做什么来优化" class="headerlink" title="可以做什么来优化"></a>可以做什么来优化</h2>常见的几种SPA首屏优化方式：</li></ul><ol><li>各种资源的压缩：<ul><li>减小资源<ul><li>减小入口文件积<br>通过懒加载的方式引入文件</li><li>静态资源本地缓存<br>  存储这方面有很多方式，一个是请求方面的的缓存机制，一种是使用work进行缓存，还有日常的本地化缓存<ul><li>http缓存<br>http缓存是一种保存资源副本并在下次请求的时候直接根据情况来使用该副本的技术。如果发现有缓存，就会拦截请求直接返回该资源的拷贝，免去了再次下载资源。有强缓存和协商缓存两种。可以参考<a href="https://qiupo.github.io/2020/11/24/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F/">浏览器缓存</a></li><li>service worker离线缓存<br>service worker是一个服务器与浏览器之间的代理人，通过他去判断哪些资源需要在加载。或者某些时候我们可以通过这个后台脚本实现后台同步内容和推送通知的操作。可以参考<a href="https://qiupo.github.io/2022/02/15/browser/serviceworker%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98/">service Worker</a></li><li>localstorage等</li></ul></li><li>UI框架按需加载<br>在引用库时，我们可以根据情况只引入部分我们需要的组件，这样可以避免引入整个库文件。将外部资源通过cdn的方式进行引入，又能减少打包体积又能加速请求。</li><li>图片资源的压缩<br>直接对图片资源进行压缩，有很多方法可以直接压缩图片体积，然后针对图标内容，可以将图标合成到一张图片上，然后在使用时只需要使用该图片并且调整到目标图表上进行展示即可。有很多在线使用的工具可以合成雪碧图并且生成图标对应的css样式。</li></ul></li><li>组件重复打包<br>如果使用的是webpack，那么webpack的<code>SplitChunks</code>插件就支持分包然后共享。具体可以直接看官网<a href="https://webpack.docschina.org/plugins/split-chunks-plugin/">split-chunks-plugin</a></li><li>开启GZip压缩<br>我们在拆包之后也可以使用<code>compression-webpack-plugin</code>压缩一下，同时在服务器端也是需要配置gzip的，如果是nginx可以直接在配置文件中配置<code>gzip:on</code>，如果是别的框架也可以使用对应的插件实现。</li></ul></li><li>使用SSR<br> ssr（server side rendering），是服务器完成页面的HTML结构拼接然后发送至浏览器的服务器渲染技术。vue直接用<code>nuxt.js</code>去搭建就好了</li><li>页面渲染性能优化</li></ol><ul><li>优化html代码<br>css放在顶部先加载，js放在底部后加载，减少DOM的总数</li><li>优化js、css会改变dom树的文件<br>使用worker把重任务分离出去，避免影响dom，减少重排重绘的发生，使css易于载入</li><li>优化动画<br>使用requestAnimationFrame来进行动画绘制，使用transform和opacity来实现一些简单的动画效果<br><a href="">页面渲染发生了什么</a><h2 id="怎么监控性能"><a href="#怎么监控性能" class="headerlink" title="怎么监控性能"></a>怎么监控性能</h2>  获取performance.timing中的值，在使用img或者sendBean的方式进行上报。或者在某些需要自定义的位置使用performance.mark进行标记，并且使用performance.measure来计算时间差来进行上报。</li><li>sendBeacon<br>  使用 sendBeacon() 方法会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。这就解决了提交分析数据时的所有的问题：数据可靠，传输异步并且不会影响下一页面的加载。  <pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;unload&#x27;</span>, logData, <span class="hljs-literal">false</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logData</span>(<span class="hljs-params"></span>) </span>&#123;    navigator.sendBeacon(<span class="hljs-string">&quot;/request&quot;</span>, analyticsData);&#125;</code></pre></li><li>img<br>  通过img发送GET请求，也可以实现日志上报，但是业务代码不能写在里面，因为图片可能会被拦截。  <pre><code class="hljs javascript"><span class="hljs-keyword">let</span> imgReq = <span class="hljs-keyword">new</span> Image();imgReq.onload = imgReq.onerror = imgReq.onabort = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">//请求结果</span>&#125;imgReq.src = url;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>首屏优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue篇</title>
    <link href="/2022/02/09/%20review/vue%E7%AF%87/"/>
    <url>/2022/02/09/%20review/vue%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h3 id="首先应该记起的内容"><a href="#首先应该记起的内容" class="headerlink" title="首先应该记起的内容"></a>首先应该记起的内容</h3><p>最应该想起的应该就是vue的生命周期部分，这是贯穿开发从始至终的部分，贴一张官网的生命周期图：<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20220209140454.png" alt="生命周期" title="生命周期"></p><p>&emsp;&emsp;在vue中，我最常使用的包括created,beforeMount,mounted,beforeDestory(最新部分已经改成beforeUnmount),destoryed(最新部分已修改成unmounted)。从图中也能很清晰的看到整个vue生命周期钩子触发的流程。那vue从<code>new Vue()</code>开始整个流程是如何进行的呢？</p><h2 id="vue解析"><a href="#vue解析" class="headerlink" title="vue解析"></a>vue解析</h2><h3 id="1-入口"><a href="#1-入口" class="headerlink" title="1.入口"></a>1.入口</h3><p>&emsp;&emsp;首先我们到github上看一下Vue是如何被定义的：<br><em><a href="https://proxy.qiupo.workers.dev/?https://github.com/vuejs/vue/blob/dev/src/core/instance/index.js">src/core/instance/index.js</a></em></p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; initMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./init&#x27;</span><span class="hljs-keyword">import</span> &#123; stateMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./state&#x27;</span><span class="hljs-keyword">import</span> &#123; renderMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./render&#x27;</span><span class="hljs-keyword">import</span> &#123; eventsMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./events&#x27;</span><span class="hljs-keyword">import</span> &#123; lifecycleMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./lifecycle&#x27;</span><span class="hljs-keyword">import</span> &#123; warn &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../util/index&#x27;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vue</span> (<span class="hljs-params">options</span>) </span>&#123;  <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp;    !(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> Vue)  ) &#123;    warn(<span class="hljs-string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)  &#125;  <span class="hljs-built_in">this</span>._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Vue</code></pre><p>&emsp;&emsp;从上面可以发现，所谓的<code>new Vue()</code>其实只是做了一个<code>_init(options)</code>操作，那这个<code>_init</code>函数是从哪里来的呢？<br>PS：在这里不得不推荐一下Octotree这个插件，可以直接很便捷的找到这个方法是在哪里被定义了和被使用了<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20220209150114.png" title="使用图片"></p><p>从工具中可以找到该方法定义在同级的init.js文件中，其中init方法是在initMixin初始化时创建的，并将_init方法挂载到Vue的原型上。</p><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initMixin</span> (<span class="hljs-params">Vue: Class&lt;Component&gt;</span>) </span>&#123;  Vue.prototype._init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options?: <span class="hljs-built_in">Object</span></span>) </span>&#123;    <span class="hljs-keyword">const</span> vm: Component = <span class="hljs-built_in">this</span>    <span class="hljs-comment">// a uid</span>    vm._uid = uid++    <span class="hljs-keyword">let</span> startTag, endTag    <span class="hljs-comment">/* istanbul ignore if */</span>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;      startTag = <span class="hljs-string">`vue-perf-start:<span class="hljs-subst">$&#123;vm._uid&#125;</span>`</span>      endTag = <span class="hljs-string">`vue-perf-end:<span class="hljs-subst">$&#123;vm._uid&#125;</span>`</span>      mark(startTag)    &#125;    <span class="hljs-comment">// a flag to avoid this being observed</span>    vm._isVue = <span class="hljs-literal">true</span>    <span class="hljs-comment">// merge options</span>    <span class="hljs-keyword">if</span> (options &amp;&amp; options._isComponent) &#123;      <span class="hljs-comment">// optimize internal component instantiation</span>      <span class="hljs-comment">// since dynamic options merging is pretty slow, and none of the</span>      <span class="hljs-comment">// internal component options needs special treatment.</span>      initInternalComponent(vm, options)    &#125; <span class="hljs-keyword">else</span> &#123;      vm.$options = mergeOptions(        resolveConstructorOptions(vm.constructor),        options || &#123;&#125;,        vm      )    &#125;    <span class="hljs-comment">/* istanbul ignore else */</span>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;      initProxy(vm)    &#125; <span class="hljs-keyword">else</span> &#123;      vm._renderProxy = vm    &#125;    <span class="hljs-comment">// expose real self</span>    vm._self = vm    initLifecycle(vm)    initEvents(vm)    initRender(vm)    callHook(vm, <span class="hljs-string">&#x27;beforeCreate&#x27;</span>)    initInjections(vm) <span class="hljs-comment">// resolve injections before data/props</span>    initState(vm)    initProvide(vm) <span class="hljs-comment">// resolve provide after data/props</span>    callHook(vm, <span class="hljs-string">&#x27;created&#x27;</span>)    <span class="hljs-comment">/* istanbul ignore if */</span>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;      vm._name = formatComponentName(vm, <span class="hljs-literal">false</span>)      mark(endTag)      measure(<span class="hljs-string">`vue <span class="hljs-subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)    &#125;    <span class="hljs-keyword">if</span> (vm.$options.el) &#123;      vm.$mount(vm.$options.el)    &#125;  &#125;&#125;</code></pre><p>&emsp;&emsp;从_init方法的执行顺序中可以发现以下代码段：</p><pre><code class="hljs javascript">initLifecycle(vm)initEvents(vm)initRender(vm)callHook(vm, <span class="hljs-string">&#x27;beforeCreate&#x27;</span>)initInjections(vm) <span class="hljs-comment">// resolve injections before data/props</span>initState(vm)initProvide(vm) <span class="hljs-comment">// resolve provide after data/props</span>callHook(vm, <span class="hljs-string">&#x27;created&#x27;</span>)</code></pre><p>&emsp;&emsp;仔细看看就能发现这一段先是初始化了一堆生命周期的标志符:</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initLifecycle</span> (<span class="hljs-params">vm: Component</span>) </span>&#123;  <span class="hljs-keyword">const</span> options = vm.$options  <span class="hljs-comment">// locate first non-abstract parent</span>  <span class="hljs-keyword">let</span> parent = options.parent  <span class="hljs-keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;    <span class="hljs-keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;      parent = parent.$parent    &#125;    parent.$children.push(vm)  &#125;  vm.$parent = parent  vm.$root = parent ? parent.$root : vm  vm.$children = []  vm.$refs = &#123;&#125;  vm._watcher = <span class="hljs-literal">null</span>  vm._inactive = <span class="hljs-literal">null</span>  vm._directInactive = <span class="hljs-literal">false</span>  vm._isMounted = <span class="hljs-literal">false</span>  vm._isDestroyed = <span class="hljs-literal">false</span>  vm._isBeingDestroyed = <span class="hljs-literal">false</span>&#125;</code></pre><p>然后初始化了事件监听</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initEvents</span> (<span class="hljs-params">vm: Component</span>) </span>&#123;  vm._events = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)  vm._hasHookEvent = <span class="hljs-literal">false</span>  <span class="hljs-comment">// init parent attached events</span>  <span class="hljs-keyword">const</span> listeners = vm.$options._parentListeners  <span class="hljs-keyword">if</span> (listeners) &#123;    updateComponentListeners(vm, listeners)  &#125;&#125;<span class="hljs-keyword">let</span> target: any<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span> (<span class="hljs-params">event, fn</span>) </span>&#123;  target.$on(event, fn)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span> (<span class="hljs-params">event, fn</span>) </span>&#123;  target.$off(event, fn)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createOnceHandler</span> (<span class="hljs-params">event, fn</span>) </span>&#123;  <span class="hljs-keyword">const</span> _target = target  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onceHandler</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> res = fn.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span>)    <span class="hljs-keyword">if</span> (res !== <span class="hljs-literal">null</span>) &#123;      _target.$off(event, onceHandler)    &#125;  &#125;&#125;</code></pre><p>再然后初始化render方法和初始化依赖注入的内容，在这里调用了defineReactive方法</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initInjections</span> (<span class="hljs-params">vm: Component</span>) </span>&#123;  <span class="hljs-keyword">const</span> result = resolveInject(vm.$options.inject, vm)  <span class="hljs-keyword">if</span> (result) &#123;    toggleObserving(<span class="hljs-literal">false</span>)    <span class="hljs-built_in">Object</span>.keys(result).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;      <span class="hljs-comment">/* istanbul ignore else */</span>      <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;        defineReactive(vm, key, result[key], <span class="hljs-function">() =&gt;</span> &#123;          warn(            <span class="hljs-string">`Avoid mutating an injected value directly since the changes will be `</span> +            <span class="hljs-string">`overwritten whenever the provided component re-renders. `</span> +            <span class="hljs-string">`injection being mutated: &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot;`</span>,            vm          )        &#125;)      &#125; <span class="hljs-keyword">else</span> &#123;        defineReactive(vm, key, result[key])      &#125;    &#125;)    toggleObserving(<span class="hljs-literal">true</span>)  &#125;&#125;</code></pre><p>随后是重点内容，在initState中按照props，methods，data，computed，watch的顺序初始化了这些内容：</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initState</span> (<span class="hljs-params">vm: Component</span>) </span>&#123;  vm._watchers = []  <span class="hljs-keyword">const</span> opts = vm.$options  <span class="hljs-keyword">if</span> (opts.props) initProps(vm, opts.props)  <span class="hljs-keyword">if</span> (opts.methods) initMethods(vm, opts.methods)  <span class="hljs-keyword">if</span> (opts.data) &#123;    initData(vm)  &#125; <span class="hljs-keyword">else</span> &#123;    observe(vm._data = &#123;&#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* asRootData */</span>)  &#125;  <span class="hljs-keyword">if</span> (opts.computed) initComputed(vm, opts.computed)  <span class="hljs-keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;    initWatch(vm, opts.watch)  &#125;&#125;</code></pre><p>&emsp;&emsp;从这里可以看出，在<code>beforeCreate</code>的时候好数据初始化还没开始，data，props的属性访问不到，然后在<code>created</code>的时候props，methods，data，computed，watch都初始化完成了，但是此时还没有发生mount所以虽然能拿到数据但是还无法访问dom元素。在最后，使用vm.$mount方法进行挂载。</p><h3 id="2-挂载"><a href="#2-挂载" class="headerlink" title="2.挂载"></a>2.挂载</h3><p>&emsp;&emsp;在上面部分能看到整个初始化的流程，那mount是如何操作的呢？</p><pre><code class="hljs javascript">Vue.prototype.$mount = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span></span><span class="hljs-params"><span class="hljs-function">  el?: string | Element,</span></span><span class="hljs-params"><span class="hljs-function">  hydrating?: boolean</span></span><span class="hljs-params"><span class="hljs-function"></span>): <span class="hljs-title">Component</span> </span>&#123;  el = el &amp;&amp; inBrowser ? query(el) : <span class="hljs-literal">undefined</span>  <span class="hljs-keyword">return</span> mountComponent(<span class="hljs-built_in">this</span>, el, hydrating)&#125;<span class="hljs-comment">//.....</span>......<span class="hljs-comment">//</span>&#125;</code></pre><p>从方法中可以看到最后是调用了<code>mountComponent</code>方法挂载组件的。进入<code>mountComponent</code>方法能看到他实在lifecycle文件中的。</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountComponent</span> (<span class="hljs-params"></span></span><span class="hljs-params"><span class="hljs-function">  vm: Component,</span></span><span class="hljs-params"><span class="hljs-function">  el: ?Element,</span></span><span class="hljs-params"><span class="hljs-function">  hydrating?: boolean</span></span><span class="hljs-params"><span class="hljs-function"></span>): <span class="hljs-title">Component</span> </span>&#123;  vm.$el = el  <span class="hljs-keyword">if</span> (!vm.$options.render) &#123;    vm.$options.render = createEmptyVNode    <span class="hljs-comment">//...</span>  &#125;  callHook(vm, <span class="hljs-string">&#x27;beforeMount&#x27;</span>)  <span class="hljs-keyword">let</span> updateComponent  <span class="hljs-comment">/* istanbul ignore if */</span>  <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;    updateComponent = <span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-keyword">const</span> name = vm._name      <span class="hljs-keyword">const</span> id = vm._uid      <span class="hljs-keyword">const</span> startTag = <span class="hljs-string">`vue-perf-start:<span class="hljs-subst">$&#123;id&#125;</span>`</span>      <span class="hljs-keyword">const</span> endTag = <span class="hljs-string">`vue-perf-end:<span class="hljs-subst">$&#123;id&#125;</span>`</span>      mark(startTag)      <span class="hljs-keyword">const</span> vnode = vm._render()      mark(endTag)      measure(<span class="hljs-string">`vue <span class="hljs-subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)      mark(startTag)      vm._update(vnode, hydrating)      mark(endTag)      measure(<span class="hljs-string">`vue <span class="hljs-subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    updateComponent = <span class="hljs-function">() =&gt;</span> &#123;      vm._update(vm._render(), hydrating)    &#125;  &#125;  <span class="hljs-comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span>  <span class="hljs-comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span>  <span class="hljs-comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span>  <span class="hljs-keyword">new</span> Watcher(vm, updateComponent, noop, &#123;    before () &#123;      <span class="hljs-keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;        callHook(vm, <span class="hljs-string">&#x27;beforeUpdate&#x27;</span>)      &#125;    &#125;  &#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* isRenderWatcher */</span>)  hydrating = <span class="hljs-literal">false</span>  <span class="hljs-comment">// manually mounted instance, call mounted on self</span>  <span class="hljs-comment">// mounted is called for render-created child components in its inserted hook</span>  <span class="hljs-keyword">if</span> (vm.$vnode == <span class="hljs-literal">null</span>) &#123;    vm._isMounted = <span class="hljs-literal">true</span>    callHook(vm, <span class="hljs-string">&#x27;mounted&#x27;</span>)  &#125;  <span class="hljs-keyword">return</span> vm&#125;</code></pre><p>&emsp;&emsp;从代码里可以看到，在这里执行了<code>beforeMount</code>方法，在此之后定义了一个<code>updateComponent</code>方法，在随后<code>new Watcher</code>监听了当前组件的状态，如果有数据更新，就会触发<code>beforeUpdate</code>来进行更新操作，当<code>_isMounted</code>为true时，就会触发<code>mounted</code>的生命周期钩子了。</p><p>&emsp;&emsp;那在这里面有两个函数格外引人注目，一个是<code>_update</code>一个是<code>_render</code>，因为这两个都涉及了很有意思的部分，一个是涉及到dom的更新，一个涉及到虚拟dom的生成。直接下钻找到他们的实现位置：</p><ul><li>_update<br>在代码中通过<code>setActiveInstance</code>保留当前作用域，然后使用<code>__patch__</code>去执行把vnode转成真实dom。在mount方法上一行就是<code>Vue.prototype.__patch__ = inBrowser ? patch : noop</code>，此时告诉我们patch方法的位置，追根溯源可以找到<a href="https://github.com/vuejs/vue/blob/23760b5c7a/src/core/vdom/patch.js">patch.js</a>实现的位置，此处在vdom下，主要就是处理vnode的。<pre><code class="hljs javascript">Vue.prototype._update = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;    <span class="hljs-keyword">const</span> vm: Component = <span class="hljs-built_in">this</span>    <span class="hljs-keyword">const</span> prevEl = vm.$el    <span class="hljs-keyword">const</span> prevVnode = vm._vnode    <span class="hljs-keyword">const</span> restoreActiveInstance = setActiveInstance(vm)    vm._vnode = vnode    <span class="hljs-comment">// Vue.prototype.__patch__ is injected in entry points</span>    <span class="hljs-comment">// based on the rendering backend used.</span>    <span class="hljs-keyword">if</span> (!prevVnode) &#123;      <span class="hljs-comment">// initial render</span>      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="hljs-literal">false</span> <span class="hljs-comment">/* removeOnly */</span>)    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// updates</span>      vm.$el = vm.__patch__(prevVnode, vnode)    &#125;    restoreActiveInstance()    <span class="hljs-comment">// update __vue__ reference</span>    <span class="hljs-keyword">if</span> (prevEl) &#123;      prevEl.__vue__ = <span class="hljs-literal">null</span>    &#125;    <span class="hljs-keyword">if</span> (vm.$el) &#123;      vm.$el.__vue__ = vm    &#125;    <span class="hljs-comment">// if parent is an HOC, update its $el as well</span>    <span class="hljs-keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;      vm.$parent.$el = vm.$el    &#125;    <span class="hljs-comment">// updated hook is called by the scheduler to ensure that children are</span>    <span class="hljs-comment">// updated in a parent&#x27;s updated hook.</span>  &#125;</code></pre></li><li>_render<br>render方法中通过vdom中的<code>createEmptyVNode</code>方法来创建vnode节点，然后设置父节点，再把此节点抛出。<pre><code class="hljs javascript">Vue.prototype._render = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>): <span class="hljs-title">VNode</span> </span>&#123;   <span class="hljs-keyword">const</span> vm: Component = <span class="hljs-built_in">this</span>   <span class="hljs-keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options   <span class="hljs-keyword">if</span> (_parentVnode) &#123;     vm.$scopedSlots = normalizeScopedSlots(       _parentVnode.data.scopedSlots,       vm.$slots,       vm.$scopedSlots     )   &#125;   <span class="hljs-comment">// set parent vnode. this allows render functions to have access</span>   <span class="hljs-comment">// to the data on the placeholder node.</span>   vm.$vnode = _parentVnode   <span class="hljs-comment">// render self</span>   <span class="hljs-keyword">let</span> vnode   <span class="hljs-keyword">try</span> &#123;     <span class="hljs-comment">// There&#x27;s no need to maintain a stack because all render fns are called</span>     <span class="hljs-comment">// separately from one another. Nested component&#x27;s render fns are called</span>     <span class="hljs-comment">// when parent component is patched.</span>     currentRenderingInstance = vm     vnode = render.call(vm._renderProxy, vm.$createElement)   &#125; <span class="hljs-keyword">catch</span> (e) &#123;     handleError(e, vm, <span class="hljs-string">`render`</span>)     <span class="hljs-comment">// return error render result,</span>     <span class="hljs-comment">// or previous vnode to prevent render error causing blank component</span>     <span class="hljs-comment">/* istanbul ignore else */</span>     <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; vm.$options.renderError) &#123;       <span class="hljs-keyword">try</span> &#123;         vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)       &#125; <span class="hljs-keyword">catch</span> (e) &#123;         handleError(e, vm, <span class="hljs-string">`renderError`</span>)         vnode = vm._vnode       &#125;     &#125; <span class="hljs-keyword">else</span> &#123;       vnode = vm._vnode     &#125;   &#125; <span class="hljs-keyword">finally</span> &#123;     currentRenderingInstance = <span class="hljs-literal">null</span>   &#125;   <span class="hljs-comment">// if the returned array contains only a single node, allow it</span>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(vnode) &amp;&amp; vnode.length === <span class="hljs-number">1</span>) &#123;     vnode = vnode[<span class="hljs-number">0</span>]   &#125;   <span class="hljs-comment">// return empty vnode in case the render function errored out</span>   <span class="hljs-keyword">if</span> (!(vnode <span class="hljs-keyword">instanceof</span> VNode)) &#123;     <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; <span class="hljs-built_in">Array</span>.isArray(vnode)) &#123;       warn(         <span class="hljs-string">&#x27;Multiple root nodes returned from render function. Render function &#x27;</span> +         <span class="hljs-string">&#x27;should return a single root node.&#x27;</span>,         vm       )     &#125;     vnode = createEmptyVNode()   &#125;   <span class="hljs-comment">// set parent</span>   vnode.parent = _parentVnode   <span class="hljs-keyword">return</span> vnode &#125;</code></pre><h3 id="3-lifecycle"><a href="#3-lifecycle" class="headerlink" title="3. lifecycle"></a>3. lifecycle</h3><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</td></tr><tr><td>created</td><td>组件初始化完毕，各种数据可以使用，常用于异步数据获取</td></tr><tr><td>beforeMount</td><td>未执行渲染、更新，dom未创建</td></tr><tr><td>mounted</td><td>初始化结束，dom已创建，可用于获取访问数据和dom元素</td></tr><tr><td>beforeUpdate</td><td>更新前，可用于获取更新前各种状态</td></tr><tr><td>updated</td><td>更新后，所有状态已是最新</td></tr><tr><td>beforeDestroy</td><td>销毁前，可用于一些定时器或订阅的取消</td></tr><tr><td>destroyed</td><td>组件已销毁，作用同上</td></tr></tbody></table></li></ul><p>&emsp;&emsp;在上面内容中总能看到lifecycle，这也是生命周期的文件，这不得重点关注一下，然后在刚刚看到的<code>_update</code>后面一下就找到了一个急救的东西<code>$forceUpdate</code>.</p><pre><code class="hljs javascript">Vue.prototype.$forceUpdate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> vm: Component = <span class="hljs-built_in">this</span>  <span class="hljs-keyword">if</span> (vm._watcher) &#123;    vm._watcher.update()  &#125;&#125;<span class="hljs-comment">// watcher</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Subscriber interface.</span><span class="hljs-comment"> * Will be called when a dependency changes.</span><span class="hljs-comment"> */</span>update () &#123;  <span class="hljs-comment">/* istanbul ignore else */</span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.lazy) &#123;    <span class="hljs-built_in">this</span>.dirty = <span class="hljs-literal">true</span>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sync) &#123;    <span class="hljs-built_in">this</span>.run()  &#125; <span class="hljs-keyword">else</span> &#123;    queueWatcher(<span class="hljs-built_in">this</span>)  &#125;&#125;  <span class="hljs-comment">/**</span><span class="hljs-comment"> * Scheduler job interface.</span><span class="hljs-comment"> * Will be called by the scheduler.</span><span class="hljs-comment"> */</span>run () &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.active) &#123;    <span class="hljs-keyword">const</span> value = <span class="hljs-built_in">this</span>.get()    <span class="hljs-keyword">if</span> (      value !== <span class="hljs-built_in">this</span>.value ||      <span class="hljs-comment">// Deep watchers and watchers on Object/Arrays should fire even</span>      <span class="hljs-comment">// when the value is the same, because the value may</span>      <span class="hljs-comment">// have mutated.</span>      isObject(value) ||      <span class="hljs-built_in">this</span>.deep    ) &#123;      <span class="hljs-comment">// set new value</span>      <span class="hljs-keyword">const</span> oldValue = <span class="hljs-built_in">this</span>.value      <span class="hljs-built_in">this</span>.value = value      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.user) &#123;        <span class="hljs-keyword">const</span> info = <span class="hljs-string">`callback for watcher &quot;<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.expression&#125;</span>&quot;`</span>        invokeWithErrorHandling(<span class="hljs-built_in">this</span>.cb, <span class="hljs-built_in">this</span>.vm, [value, oldValue], <span class="hljs-built_in">this</span>.vm, info)      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">this</span>.cb.call(<span class="hljs-built_in">this</span>.vm, value, oldValue)      &#125;    &#125;  &#125;&#125;</code></pre><p><code>$forceUpdate</code>的作用是当数据刷新后视图却没有跟着刷新时的抢救措施，让他强制刷新一下。看代码中主要的行为就是使用了watcher中的update方法，所以<code>$forceUpdate</code>其实是会触发<code>beforeUpdate</code>和<code>updated</code>的，但是不会重新加载组件。</p>]]></content>
    
    
    <categories>
      
      <category>复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript隐式转换</title>
    <link href="/2021/09/20/javascript%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <url>/2021/09/20/javascript%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>JavaScript 的隐式转换会发生在比较和运算的时候，比如++ – - + == &gt; &lt; &gt;= &lt;=中，在执行代码时，如果值不是数字类型就会发生隐式转换，所以会出现很多奇怪的情况，在此进行一些想法的记录。</p><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><p>递增递减<br><code>-- ++</code><br>加减<br><code>+-</code></p><ol><li>都是数字正常操作</li><li>只要有一个字符串，管你是什么都转成字符串接上</li><li>在有对象时先通过 Symbol.toPrimitive 找到原始类型判断是否有 valueOf()，没有或者返回 NaN，有就直接调用 toString()，f(),[]是’’,所以符合 1⃣️,,{}是”[object Object]”,所以也符合 1<br>但是{}在前的时候直接在 chrome 浏览器 console 输出会有不同的情况，可能是浏览器 console 的规则不同。<ul><li>{}+any 都会把后面的通过 Number()转换后输出</li><li>{}+{} 是[object Object][object object]</li><li>{}+{}; 是 NaN，估计是{};会当作一个执行块，Number()转的结果是 NaN</li><li>{}+undefined 是 NaN</li></ul></li><li>Infinity 和 Infinity 相加正常操作</li><li>+-Infinity 和+-null、+-undefined 相加是 NaN</li><li>+0 -0 正常操作，除了-0+0 是+0</li><li>+-null 和+-undefined 相加 NaN</li><li>null 在没有’’时，转成 0 进行处理</li></ol><pre><code class="hljs javascript"><span class="hljs-literal">Infinity</span>+<span class="hljs-literal">Infinity</span> <span class="hljs-comment">//Infinity</span>-<span class="hljs-literal">Infinity</span>+-<span class="hljs-literal">Infinity</span> <span class="hljs-comment">//-Infinity</span><span class="hljs-literal">Infinity</span>-<span class="hljs-literal">Infinity</span> <span class="hljs-comment">//NaN</span><span class="hljs-literal">NaN</span>+any <span class="hljs-comment">//NaN</span><span class="hljs-number">0</span>+<span class="hljs-number">0</span> <span class="hljs-comment">//0</span><span class="hljs-number">0</span>-<span class="hljs-number">0</span> <span class="hljs-comment">//+0</span>-<span class="hljs-number">0</span>-<span class="hljs-number">0</span> <span class="hljs-comment">//-0</span>&#123;&#125;+&#123;&#125; <span class="hljs-comment">//[object Object][object Object]</span>&#123;&#125;+&#123;&#125;; <span class="hljs-comment">//NaN</span>&#123;&#125;+<span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-comment">//NaN</span>&#123;&#125;+<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-comment">//1</span>&#123;&#125;+[] <span class="hljs-comment">//0</span>&#123;&#125;+<span class="hljs-literal">null</span> <span class="hljs-comment">//0</span>&#123;&#125;+<span class="hljs-literal">undefined</span> <span class="hljs-comment">//NaN</span><span class="hljs-keyword">var</span> s =&#123;&#125; +anys <span class="hljs-comment">//&quot;[object Object]any&quot;</span>any+&#123;&#125; <span class="hljs-comment">//&quot;any[object Object]&quot;</span>[]+[] <span class="hljs-comment">//&quot;&quot;</span>[]+<span class="hljs-literal">Infinity</span> <span class="hljs-comment">//Infinity</span>[]+<span class="hljs-number">1</span> <span class="hljs-comment">//1</span></code></pre><ol><li>都是数字正常操作</li><li>Infinity-Infinity 是 NaN -Infinity-Infinity 是-Infinity，其他情况可以转成加法</li><li>-0，+0 和加法一样</li><li>有一个是字符串、boolean、null 和 undefined，调用 Number()转成数值操作，如果结果是 NaN，那么结果就是 NaN</li><li>如果有对象，那么进行 valueOf()获得数值操作，如果是 NaN，那结果就是 NaN，如果没有 valueOf()，调用 toString()然后转成数值进行操作。<h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><code>&gt; &gt; = &lt; &lt;=</code><br>抽象关系比较的隐式转换也是分情况讨论的，不过比较简单</li><li>都是数字正常比较</li><li>不全是，则先进行两边先进行 toPrimitive 转换后，只要有非字符串类型的，双方就进行 toNumber()转换，然后比较</li><li>如果都是字符串，则按照字母的顺序进行比较。如：[“044”]&gt;[“422”] 是 false，因为先比较第一个”0”和”4”，发现”0”在字符顺序上是小于”4”的，所以是 false</li><li>JavaScript 中会&gt;=转换成&lt;进行比较，比如 a&gt;=b 会转换成!(a&lt;b)，进行比较操作，&lt;=同理。</li></ol><pre><code class="hljs javascript"><span class="hljs-number">1</span>&gt;<span class="hljs-number">1</span> <span class="hljs-comment">//false</span>[<span class="hljs-number">123</span>] &gt; <span class="hljs-string">&quot;01222&quot;</span> <span class="hljs-comment">//true</span>[<span class="hljs-number">123</span>] &gt; <span class="hljs-number">01222</span> <span class="hljs-comment">//false</span><span class="hljs-string">&quot;1&quot;</span> &gt; <span class="hljs-string">&quot;0123&quot;</span> <span class="hljs-comment">//true</span><span class="hljs-keyword">var</span> a1 = &#123;<span class="hljs-attr">a</span> : <span class="hljs-number">1</span>&#125;<span class="hljs-keyword">var</span> b1 = &#123;<span class="hljs-attr">b</span> : <span class="hljs-number">1</span>&#125;a1 &gt; b1 <span class="hljs-comment">//false</span>a1 &lt; b1 <span class="hljs-comment">//false</span>a1 == b1 <span class="hljs-comment">//false</span>a1 &gt;= b1 <span class="hljs-comment">//true</span>a1 &lt;= b1 <span class="hljs-comment">//true</span></code></pre><h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><p><code>== != === !===</code><br>有两种相等，宽松相等和严格相等，严格相等不会进行隐式转换，会比较类型和值是否相等，所以推荐使用！但是宽松相等就会进行隐式转换。所以会有很多奇怪的情况出现。以下是 ES5 的规定：<br>比较运算 x==y, 其中 x 和 y 是值，返回 true 或者 false。这样的比较按如下方式进行：</p><pre><code class="hljs json"><span class="hljs-number">1</span>、若 Type(x) 与 Type(y) 相同， 则    <span class="hljs-number">1</span>* 若 Type(x) 为 Undefined， 返回 <span class="hljs-literal">true</span>。    <span class="hljs-number">2</span>* 若 Type(x) 为 Null， 返回 <span class="hljs-literal">true</span>。    <span class="hljs-number">3</span>* 若 Type(x) 为 Number， 则        (<span class="hljs-number">1</span>)、若 x 为 NaN， 返回 <span class="hljs-literal">false</span>。        (<span class="hljs-number">2</span>)、若 y 为 NaN， 返回 <span class="hljs-literal">false</span>。        (<span class="hljs-number">3</span>)、若 x 与 y 为相等数值， 返回 <span class="hljs-literal">true</span>。        (<span class="hljs-number">4</span>)、若 x 为 +<span class="hljs-number">0</span> 且 y 为 −<span class="hljs-number">0</span>， 返回 <span class="hljs-literal">true</span>。        (<span class="hljs-number">5</span>)、若 x 为 −<span class="hljs-number">0</span> 且 y 为 +<span class="hljs-number">0</span>， 返回 <span class="hljs-literal">true</span>。        (<span class="hljs-number">6</span>)、返回 <span class="hljs-literal">false</span>。    <span class="hljs-number">4</span>* 若 Type(x) 为 String, 则当 x 和 y 为完全相同的字符序列（长度相等且相同字符在相同位置）时返回 <span class="hljs-literal">true</span>。 否则， 返回 <span class="hljs-literal">false</span>。    <span class="hljs-number">5</span>* 若 Type(x) 为 Boolean, 当 x 和 y 为同为 <span class="hljs-literal">true</span> 或者同为 <span class="hljs-literal">false</span> 时返回 <span class="hljs-literal">true</span>。 否则， 返回 <span class="hljs-literal">false</span>。    <span class="hljs-number">6</span>*  当 x 和 y 为引用同一对象时返回 <span class="hljs-literal">true</span>。否则，返回 <span class="hljs-literal">false</span>。<span class="hljs-number">2</span>、若 x 为 <span class="hljs-literal">null</span> 且 y 为 undefined， 返回 <span class="hljs-literal">true</span>。<span class="hljs-number">3</span>、若 x 为 undefined 且 y 为 <span class="hljs-literal">null</span>， 返回 <span class="hljs-literal">true</span>。<span class="hljs-number">4</span>、若 Type(x) 为 Number 且 Type(y) 为 String，返回比较 x == ToNumber(y) 的结果。<span class="hljs-number">5</span>、若 Type(x) 为 String 且 Type(y) 为 Number，返回比较 ToNumber(x) == y 的结果。<span class="hljs-number">6</span>、若 Type(x) 为 Boolean， 返回比较 ToNumber(x) == y 的结果。<span class="hljs-number">7</span>、若 Type(y) 为 Boolean， 返回比较 x == ToNumber(y) 的结果。<span class="hljs-number">8</span>、若 Type(x) 为 String 或 Number，且 Type(y) 为 Object，返回比较 x == ToPrimitive(y) 的结果。<span class="hljs-number">9</span>、若 Type(x) 为 Object 且 Type(y) 为 String 或 Number， 返回比较 ToPrimitive(x) == y 的结果。<span class="hljs-number">10</span>、返回 <span class="hljs-literal">false</span>。</code></pre><p>简而言之就是如果类型不同，转成数字在进行对比，如果类型相同，boolean 的就正常比，string 的就比每一位的字符，对象就比是否是引用同一对象。下面是小黄书上的对比图：<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/202202211016600.png" title="小红书对比图"><br>其中有些特殊情况，比如””==[null]是 true，因为右边的会进行强制类型转换，然后得到””，所以相等<br>[]==![]是 true，因为!非的操作会进行 Boolean 类型转换，但是在 js 中只有 null，undefined，0，””，NaN，false 是会转成 false，其他都是 true，所以[]会转成 true，然后非一下就是 false 然后[]==false，所以是 true<br>这其中对象在进行比较是会进行 toPrimitive 操作然后 valueOf()，在进行对比，如果进行了元编程修改了 toPrimitive 或者 valueOf，使其会有副作用，则对象的相等也会出现不一样的效果。</p><ul><li>修改 valueOf<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-built_in">Number</span>.prototype.valueOf = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">return</span> a++;&#125;;<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">12</span>);b == <span class="hljs-number">1</span>; <span class="hljs-comment">//true</span>b == <span class="hljs-number">2</span>; <span class="hljs-comment">//true</span></code></pre></li><li>修改toPrimitive<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-built_in">Number</span>[<span class="hljs-built_in">Symbol</span>.toPrimitive] = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">return</span> a++;&#125;;<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">12</span>);b == <span class="hljs-number">1</span>; <span class="hljs-comment">//true</span>b == <span class="hljs-number">2</span>; <span class="hljs-comment">//true</span></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>隐式转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器环境配置</title>
    <link href="/2021/08/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/08/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="一台全新的服务器从头开始配置记录"><a href="#一台全新的服务器从头开始配置记录" class="headerlink" title="一台全新的服务器从头开始配置记录"></a><strong>一台全新的服务器从头开始配置记录</strong></h2><p>首先明确我们需要做什么，需要安装哪些东西:</p><table><thead><tr><th></th><th>需要做的</th></tr></thead><tbody><tr><td>1</td><td>挂载数据盘</td></tr><tr><td>2</td><td>安装 git</td></tr><tr><td>3</td><td>安装 npm,node</td></tr><tr><td>4</td><td>安装 nrm</td></tr><tr><td>5</td><td>安装 oh-my-zsh，并且配置 zsh-autosuggestions</td></tr><tr><td>6</td><td>安装 powerlevel10k 完成配置</td></tr><tr><td>7</td><td>安装 nginx 和 pm2</td></tr></tbody></table><ol><li><p>挂载硬盘<br>因为我的服务器买的时候送了一块 200g 的数据盘（我之前也发现原本的 50g 完全不够用），所以需要在服务器一启动就把数据盘挂载在我们想要挂载的文件路径上。<br>参考：<a href="https://cloud.tencent.com/document/product/362/6734">https://cloud.tencent.com/document/product/362/6734</a></p><ol><li>先执行<code>fdisk -l</code>查看云服务器上的硬盘情况:<br><code>/dev/vda</code> 是系统盘，<code>/dev/vdb</code> 是新增数据盘<br>![]<a href="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20210811141222.png">https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20210811141222.png</a>)<br>这样，我们就找到了我们需要挂载的数据盘,然后对设备直接创建文件系统<br><code>mkfs -t ext4 /dev/vdb</code><br>这样就格式化好了，然后新建挂载点并且挂载上去就可以了<br><code>mkdir /mydata</code><br><code>mount /dev/vdb /mydata</code><br>在输入<code>df -TH</code>即可查看是否挂载成功<br>![]<a href="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20210811141610.png">https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20210811141610.png</a>)</li></ol></li><li><p>安装 git<br>参考官网：<a href="https://git-scm.com/download/linux">https://git-scm.com/download/linux</a><br>直接运行<code>yun install git</code>即可</p></li><li><p>安装 npm,node<br>这里通过<a href="https://docs.npmjs.com/cli/v7/configuring-npm/install">官网</a>的介绍，我选择安装<code>n</code>进行 npm 和 node 的管理，也比较简单方便。<br>通过<code>n</code>的<a href="https://github.com/tj/n">仓库</a>说明可以得知，因为我们没有 npm，所以需要另一种引导安装的方式：</p><pre><code class="hljs awk">curl -L https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/tj/</span>n<span class="hljs-regexp">/master/</span>bin/n -o nbash n lts<span class="hljs-comment"># Now node and npm are available</span></code></pre><p>现在 npm 和 node 都可以使用了。</p></li><li><p>安装 nrm<br>安装 nrm 对 npm 的镜像进行管理是非常有必要的，执行：<code>npm install -g nrm</code><br>然后切换淘宝镜像即可。</p></li><li><p>安装 oh-my-zsh<br>需要安装 omz，我们需要先给服务器装上 zsh 才行，<code>yum install -y zsh</code><br>参考官网：<a href="https://ohmyz.sh/#install">https://ohmyz.sh/#install</a><br>执行以下命令即可把 ohmyzsh 安装到终端下</p><pre><code class="hljs bash">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)</span>&quot;</span></code></pre><p>此时 omz 就安装好了，然后装一个命令步全的插件就够用了，</p><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/zsh-users/</span>zsh-autosuggestions <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span><span class="hljs-regexp">/plugins/</span>zsh-autosuggestions</code></pre><p><strong>ps：此处如果下不动可以将<code>github.com</code>切换成<code>github.com.cnpmjs.org</code>,即可实现下载</strong></p><p>下载完成后，执行<code>vim ~/.zshrc</code>修改 plugins 成这样就可以了</p><pre><code class="hljs makefile">plugins=(    <span class="hljs-comment"># other plugins...</span>    zsh-autosuggestions)</code></pre></li><li><p>安装 powerlevel10k<br>powerlevel10k 是一个很好用主题，安装也很简单</p><pre><code class="hljs awk">git clone --depth=<span class="hljs-number">1</span> https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/romkatv/</span>powerlevel10k.git <span class="hljs-variable">$&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;</span><span class="hljs-regexp">/themes/</span>powerlevel10k</code></pre><p>下载完成后，执行<code>vim ~/.zshrc</code>修改 ZSH_THEME 成这样就可以了</p><pre><code class="hljs ini"><span class="hljs-attr">ZSH_THEME</span>=<span class="hljs-string">&quot;powerlevel10k/powerlevel10k&quot;</span></code></pre><p>保存后执行，<code>source ~/.zshrc</code>后，会进入配置界面，进行必要的配置就行了，具体的优化可以自查。</p></li><li><p>安装 nginx 和 pm2<br>参考官网：<a href="https://nginx.org/en/linux_packages.html">https://nginx.org/en/linux_packages.html</a><br>找到 centos 的安装方法，运行：<code>sudo yum install yum-utils</code><br>然后设置 yum 存储库，创建/etc/yum.repos.d/nginx.repo 命名的文件</p><pre><code class="hljs ini"><span class="hljs-section">[nginx-stable]</span><span class="hljs-attr">name</span>=nginx stable repo<span class="hljs-attr">baseurl</span>=http://nginx.org/packages/centos/<span class="hljs-variable">$releasever</span>/<span class="hljs-variable">$basearch</span>/<span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span><span class="hljs-attr">enabled</span>=<span class="hljs-number">1</span><span class="hljs-attr">gpgkey</span>=https://nginx.org/keys/nginx_signing.key<span class="hljs-attr">module_hotfixes</span>=<span class="hljs-literal">true</span><span class="hljs-section">[nginx-mainline]</span><span class="hljs-attr">name</span>=nginx mainline repo<span class="hljs-attr">baseurl</span>=http://nginx.org/packages/mainline/centos/<span class="hljs-variable">$releasever</span>/<span class="hljs-variable">$basearch</span>/<span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span><span class="hljs-attr">enabled</span>=<span class="hljs-number">0</span><span class="hljs-attr">gpgkey</span>=https://nginx.org/keys/nginx_signing.key<span class="hljs-attr">module_hotfixes</span>=<span class="hljs-literal">true</span></code></pre><p> 然后运行<code>sudo yum install nginx</code>和<code>npm install pm2@latest -g</code>即可安装好nginx和pm2了</p></li></ol><p><strong><em>终于完成基本的配置了,可以进入我真正想做的事情了———搭建jenkins实现ci/cd</em></strong></p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jenkins安装</title>
    <link href="/2021/08/11/CICD/jenkins%E5%AE%89%E8%A3%85/"/>
    <url>/2021/08/11/CICD/jenkins%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="jenkins安装"><a href="#jenkins安装" class="headerlink" title="jenkins安装"></a>jenkins安装</h2><p>&emsp;&emsp;<strong>jenkins</strong>作为领先的开源自动化服务器，Jenkins 提供了数百个插件来支持任何项目的构建、部署和自动化。<br>&emsp;&emsp;在官网有安装步骤 <a href="https://www.jenkins.io/doc/book/installing/linux/">https://www.jenkins.io/doc/book/installing/linux/</a><br>因为我的服务器是CentOS,所以需要以下命令：</p><pre><code class="hljs awk">sudo wget -O <span class="hljs-regexp">/etc/yum</span>.repos.d/jenkins.repo \    https:<span class="hljs-regexp">//</span>pkg.jenkins.io<span class="hljs-regexp">/redhat-stable/</span>jenkins.reposudo rpm --import https:<span class="hljs-regexp">//</span>pkg.jenkins.io<span class="hljs-regexp">/redhat-stable/</span>jenkins.io.keysudo yum upgradesudo yum install jenkins java-<span class="hljs-number">11</span>-openjdk-develsudo systemctl daemon-reload</code></pre><h3 id="其中遇到的问题"><a href="#其中遇到的问题" class="headerlink" title="其中遇到的问题"></a>其中遇到的问题</h3><ol><li><p>存储不足报错</p><pre><code class="hljs applescript">One <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> configured repositories failed (Unknown), <span class="hljs-keyword">and</span> yum doesn&#x27;t have enough cached data <span class="hljs-keyword">to</span> <span class="hljs-keyword">continue</span>. At this point <span class="hljs-keyword">the</span> only safe thing yum can do <span class="hljs-keyword">is</span> fail. There are a few ways <span class="hljs-keyword">to</span> work <span class="hljs-string">&quot;fix&quot;</span> this:     <span class="hljs-number">1.</span> Contact <span class="hljs-keyword">the</span> upstream <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> repository <span class="hljs-keyword">and</span> <span class="hljs-keyword">get</span> them <span class="hljs-keyword">to</span> fix <span class="hljs-keyword">the</span> problem.     <span class="hljs-number">2.</span> Reconfigure <span class="hljs-keyword">the</span> baseurl/etc. <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> repository, <span class="hljs-keyword">to</span> point <span class="hljs-keyword">to</span> a working        upstream. This <span class="hljs-keyword">is</span> most often useful <span class="hljs-keyword">if</span> you are using a newer        distribution release than <span class="hljs-keyword">is</span> supported <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> repository (<span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span>        packages <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> previous distribution release still work).     <span class="hljs-number">3.</span> Run <span class="hljs-keyword">the</span> command <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> repository temporarily disabled            yum <span class="hljs-comment">--disablerepo=&lt;repoid&gt; ...</span>     <span class="hljs-number">4.</span> Disable <span class="hljs-keyword">the</span> repository permanently, so yum won&#x27;t use <span class="hljs-keyword">it</span> <span class="hljs-keyword">by</span> default. Yum        will <span class="hljs-keyword">then</span> just ignore <span class="hljs-keyword">the</span> repository <span class="hljs-keyword">until</span> you permanently enable <span class="hljs-keyword">it</span>        again <span class="hljs-keyword">or</span> use <span class="hljs-comment">--enablerepo for temporary usage:</span>            yum-config-manager <span class="hljs-comment">--disable &lt;repoid&gt;</span>        <span class="hljs-keyword">or</span>            subscription-manager repos <span class="hljs-comment">--disable=&lt;repoid&gt;</span>     <span class="hljs-number">5.</span> Configure <span class="hljs-keyword">the</span> failing repository <span class="hljs-keyword">to</span> be skipped, <span class="hljs-keyword">if</span> <span class="hljs-keyword">it</span> <span class="hljs-keyword">is</span> unavailable.        Note <span class="hljs-keyword">that</span> yum will <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> contact <span class="hljs-keyword">the</span> repo. when <span class="hljs-keyword">it</span> runs most commands,        so will have <span class="hljs-keyword">to</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">and</span> fail each <span class="hljs-built_in">time</span> (<span class="hljs-keyword">and</span> thus. yum will be be much        slower). If <span class="hljs-keyword">it</span> <span class="hljs-keyword">is</span> a very temporary problem though, this <span class="hljs-keyword">is</span> often a nice        compromise:            yum-config-manager <span class="hljs-comment">--save --setopt=&lt;repoid&gt;.skip_if_unavailable=true</span>Insufficient <span class="hljs-literal">space</span> <span class="hljs-keyword">in</span> download directory /var/cache/yum/x86_64/<span class="hljs-number">7</span>/base    * free   <span class="hljs-number">0</span>     * needed <span class="hljs-number">100</span> k</code></pre><p>&emsp;&emsp;其中问题存在与cached data不足，这里是因为我的服务器只有50G，不够用,执行<code>df -h</code>查看存储情况后发现有一块额外的200G挂载硬盘，只需要修改yum地址到外挂硬盘就行了，执行以下命令：</p><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/yum</span>.conf</code></pre><p>会出现以下配置内容：</p><pre><code class="hljs ini"><span class="hljs-section">[main]</span><span class="hljs-attr">cachedir</span>=/var/cache/yum/<span class="hljs-variable">$basearch</span>/<span class="hljs-variable">$releasever</span><span class="hljs-attr">keepcache</span>=<span class="hljs-number">0</span><span class="hljs-attr">debuglevel</span>=<span class="hljs-number">2</span></code></pre><p>修改<code>cachedir</code>此处的地址修改到挂载的文件路径即可。</p></li><li><p>filesystem没有足够的空间</p><pre><code class="hljs apache"><span class="hljs-attribute">At</span> least <span class="hljs-number">1105</span>MB more space needed <span class="hljs-literal">on</span> the / filesystem.</code></pre><p>在执行<code>sudo yum upgrade</code>时报以上错误。只需修改<code>yum.conf</code>，添加一行<code>diskspacecheck=0</code>即可解决问题</p></li><li><p>安装jenkins失败<br>如果失败了，建议通过清华的镜像站自行下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat/">https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat/</a><br>然后scp或者ftp传输到服务器上，<code>rpm -ivh jenkins-2xxx.noarch.rpm</code><br>就可以了。</p></li></ol><h3 id="安装完毕"><a href="#安装完毕" class="headerlink" title="安装完毕"></a>安装完毕</h3><p>完成后运行 </p><pre><code class="hljs smali">sudo<span class="hljs-keyword"> system</span>ctl daemon-reloadsudo<span class="hljs-keyword"> system</span>ctl start jenkins</code></pre><p>便可以启动jenkins，然后通过<code>sudo systemctl status jenkins</code>查看状态<br>之后按照官网步骤即可访问jenkins的网页了，输入密码然后进入引导页面即可。</p>]]></content>
    
    
    <categories>
      
      <category>jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CI/CD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器v2ray协议学习</title>
    <link href="/2021/01/13/%E6%9C%8D%E5%8A%A1%E5%99%A8v2ray%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/01/13/%E6%9C%8D%E5%8A%A1%E5%99%A8v2ray%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="v2ray搭建"><a href="#v2ray搭建" class="headerlink" title="v2ray搭建"></a>v2ray搭建</h2><p>&emsp;&emsp;之前看过一些网络协议，在研究的时候就发现有这么个v2ray的工具，可以加密连接，所以拿来研究以下。</p><ol><li>首先你需要买一台服务器/轻量云服务器，哪个便宜买哪个，我自己测试之后，8M的带宽就能完全应付日常使用了，装上Centos系统。</li><li>买好之后ssh连接到服务器上，可以用电脑自带的终端/cmd，或者用别的软件，我用的是Termius，比较方便，输入账号密码之后，进入服务器</li><li>我之前使用的官方自己的代码搭建的，虽然也可以但是不够直观，所以又找到一个比较好的轮子，v2-ui，可以在可视化的操控v2ray的连接情况。只需要在控制台输入<pre><code class="hljs awk">bash &lt;(curl -Ls https:<span class="hljs-regexp">//</span>blog.sprov.xyz/v2-ui.sh)</code></pre>一般来说都没问题的，会直接进入下面的环节，然后就是漫长的等待，等待他下完v2-ui-linux，如果网速快不需要的多久，不快的话可能就得20来分钟了.<br>项目地址是<a href="https://github.com/sprov065/v2-ui">v2-ui</a></li></ol><ul><li>PS:如果遇到连接问题，修改etc/hosts，新增一行<pre><code class="hljs accesslog"><span class="hljs-number">199.232.28.133</span> raw.githubusercontent.com</code></pre>大概率可以解决问题的。</li><li>如果输入命令没有显示，需要把<code>-Ls</code>改成<code>-L</code>，这样就把错误暴露出来了，可以直接按照错误去修正</li></ul><ol start="4"><li>全新安装后，在浏览器中打开 http://&lt;服务器IP&gt;:65432 即可访问面板，默认用户名和密码都是 admin，当然你也可以在控制面板中输入v2-ui,按照提示修改端口和重置。</li></ol><p><strong><em>！！！不过请你一定要到服务器的安全设置里，将端口放行，一般在安全配置里面，不放行是进不去网页的</em></strong></p><ol start="5"><li><p>进入网页后的操作就简单多了，直接添加就行，改动端口和传输配置ws或者tcp，可以自行研究</p></li><li><p>另外呢，还可以自己添加bbr加速tcp连接，可以让网速更快，直接在控制台输入这个：</p><pre><code class="hljs sas">wget -N --no-<span class="hljs-meta">check</span>-certificate <span class="hljs-string">&quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot;</span> <span class="hljs-variable">&amp;&amp;</span> chmod +<span class="hljs-meta">x</span> tcp.sh <span class="hljs-variable">&amp;&amp;</span> ./tcp.sh</code></pre></li><li><p>运行完之后会出现脚本页面，自己选择安装魔改还是plus，整个流程大致就是先按1或者2 ，然后在按照提示运行完成后，在次进入这个页面输入4或者5或者6，成功之后就会显示开启成功，加速成功啦。</p></li><li><p>服务器最好dd以下系统，给你一个纯净系统<br>综上就是大致的流程了。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>v2ray</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些想到的问题</title>
    <link href="/2020/12/22/%20review/%E4%B8%80%E4%BA%9B%E6%83%B3%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/12/22/%20review/%E4%B8%80%E4%BA%9B%E6%83%B3%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1、Vue中父子组件的加载顺序？<br>&emsp;&emsp;父子组件在加载时</p><ul><li>如果子组件是同步加载的，那么父组件会先created然后在beforemounted时对子组件进行created，子组件根据在父组件中使用的顺序进行created，当所有子组件被mounted时，父组件才会进行mounted。</li><li>如果子组件时懒加载模式，那么父组件会在created，mounted之后的beforeUpdate时根据子组件的顺序进行子组件的created和mounted</li></ul><p>2、浏览器每一帧发生了什么事情？<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201223165207.png"><br>3、页面适配怎么做？rem什么原理？<br>&emsp;&emsp;@media screen可以进行区分，也可以使用viewport进行缩放，或者使用rem根据html根元素的font-size进行缩放，很少使用em，因为em是根据父元素的font-size进行缩放，而且每个组件的em值可能都是不一样很难管理<br>4、贪心和分治说一下？<br>&emsp;&emsp;贪心通俗理解为找到局部最优解，在局部情况下我只找最接近结果的情况，然后所有情况加在一起得到最终最优解，该算法必须一系列子问题中每个子问题不依赖于后面子问题的解，我才能确定当前子问题的局部最优解不会影响最终解；<br>&emsp;&emsp;分治算法也是大问题拆解成小问题注意解决的情况。比较经典的就是快速排序算法，和归并排序，快排是通过找到一个mid值，然后把小于的放左边大于的放右边，然后左右再继续执行相同的操作来进行排序的，这就是把大的排序问题拆解成小的排序问题，直到最后解决了小问题，那么大问题也得到解决。归并中也是类似，把数分成两堆，然后解决小问题的排序问题，最后把小的排序结果进行归并操作得到最终排序结果。<br>5、Vue的生命周期有啥？<br>&emsp;&emsp;有几个重要阶段：beforeCreate，created，beforeMount，mounted，beforeUpdate，updated，beforeDestroy，destroyed，分别是组件创建，组件载入，组件更新，组件销毁，其中数据是在created时就被获得，载入时数据载入Dom<br>6、Webpack你是用什么进行打包优化的？<br>&emsp;&emsp;我用的是hard-sourse-webpack-plugin，因为他第一次要缓存所以第一次时速度没有变化，但是第二次的速度就能特别快，提升很显著，起码在80%以上，选这个是因为这玩意很简单，只需要导入后然后在plugins里加上new HardSourceWebpackPlugin就能实现基本功能，特别简单好用。</p><p>#奇奇怪怪的问题</p><h2 id="Proxy相对于Objec-defineProperty的优势？区别？"><a href="#Proxy相对于Objec-defineProperty的优势？区别？" class="headerlink" title="Proxy相对于Objec.defineProperty的优势？区别？"></a>Proxy相对于Objec.defineProperty的优势？区别？</h2><h2 id="常见的dom操作有哪些？"><a href="#常见的dom操作有哪些？" class="headerlink" title="常见的dom操作有哪些？"></a>常见的dom操作有哪些？</h2><h2 id="页面中哪些时候会进行重绘重排"><a href="#页面中哪些时候会进行重绘重排" class="headerlink" title="页面中哪些时候会进行重绘重排"></a>页面中哪些时候会进行重绘重排</h2><h2 id="Webpack的原理？有哪些好处？"><a href="#Webpack的原理？有哪些好处？" class="headerlink" title="Webpack的原理？有哪些好处？"></a>Webpack的原理？有哪些好处？</h2><h2 id="首屏加载优化方案？"><a href="#首屏加载优化方案？" class="headerlink" title="首屏加载优化方案？"></a>首屏加载优化方案？</h2><h2 id="有哪些性能优化方法？为什么可以达到优化？怎么做性能监控？"><a href="#有哪些性能优化方法？为什么可以达到优化？怎么做性能监控？" class="headerlink" title="有哪些性能优化方法？为什么可以达到优化？怎么做性能监控？"></a>有哪些性能优化方法？为什么可以达到优化？怎么做性能监控？</h2><p><a href="https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution?hl=zh-cn">一个优化文章</a></p><h2 id="重绘和回流-是什么，在什么时候发生，机制是什么，如果减少？"><a href="#重绘和回流-是什么，在什么时候发生，机制是什么，如果减少？" class="headerlink" title="重绘和回流 是什么，在什么时候发生，机制是什么，如果减少？"></a>重绘和回流 是什么，在什么时候发生，机制是什么，如果减少？</h2><h2 id="cookies，sessionStorage和localStorage的区别？除了这些indexedDb和Web-SQL又是什么"><a href="#cookies，sessionStorage和localStorage的区别？除了这些indexedDb和Web-SQL又是什么" class="headerlink" title="cookies，sessionStorage和localStorage的区别？除了这些indexedDb和Web SQL又是什么?"></a>cookies，sessionStorage和localStorage的区别？除了这些indexedDb和Web SQL又是什么?</h2><h2 id="vue响应式原理的理解？vue3和vue2有什么区别，怎么看待官方推送版本变成了vue3？"><a href="#vue响应式原理的理解？vue3和vue2有什么区别，怎么看待官方推送版本变成了vue3？" class="headerlink" title="vue响应式原理的理解？vue3和vue2有什么区别，怎么看待官方推送版本变成了vue3？"></a>vue响应式原理的理解？vue3和vue2有什么区别，怎么看待官方推送版本变成了vue3？</h2><h2 id="vue数据双向绑定的原理，哪些时候会失效，失效了又要如何处理？"><a href="#vue数据双向绑定的原理，哪些时候会失效，失效了又要如何处理？" class="headerlink" title="vue数据双向绑定的原理，哪些时候会失效，失效了又要如何处理？"></a>vue数据双向绑定的原理，哪些时候会失效，失效了又要如何处理？</h2><h2 id="浏览器工作原理–浏览器如何渲染页面？"><a href="#浏览器工作原理–浏览器如何渲染页面？" class="headerlink" title="浏览器工作原理–浏览器如何渲染页面？"></a>浏览器工作原理–浏览器如何渲染页面？</h2><h2 id="什么情况会导致内存泄漏？"><a href="#什么情况会导致内存泄漏？" class="headerlink" title="什么情况会导致内存泄漏？"></a>什么情况会导致内存泄漏？</h2><h2 id="浏览器工作原理–浏览器如何实现垃圾回收？计数？三色标记？v8的新老空间？"><a href="#浏览器工作原理–浏览器如何实现垃圾回收？计数？三色标记？v8的新老空间？" class="headerlink" title="浏览器工作原理–浏览器如何实现垃圾回收？计数？三色标记？v8的新老空间？"></a>浏览器工作原理–浏览器如何实现垃圾回收？计数？三色标记？v8的新老空间？</h2><h2 id="浏览器兼容性问题及其解决方法"><a href="#浏览器兼容性问题及其解决方法" class="headerlink" title="浏览器兼容性问题及其解决方法"></a>浏览器兼容性问题及其解决方法</h2><h2 id="AMD和CMD和commonjs的区别"><a href="#AMD和CMD和commonjs的区别" class="headerlink" title="AMD和CMD和commonjs的区别"></a>AMD和CMD和commonjs的区别</h2><h2 id="什么是虚拟dom？为什么虚拟dom能提升性能？vue和react的domdiff算法有啥区别？react各个版本针对dom又做了什么优化"><a href="#什么是虚拟dom？为什么虚拟dom能提升性能？vue和react的domdiff算法有啥区别？react各个版本针对dom又做了什么优化" class="headerlink" title="什么是虚拟dom？为什么虚拟dom能提升性能？vue和react的domdiff算法有啥区别？react各个版本针对dom又做了什么优化"></a>什么是虚拟dom？为什么虚拟dom能提升性能？vue和react的domdiff算法有啥区别？react各个版本针对dom又做了什么优化</h2><h2 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h2><h2 id="原型和原型链的理解"><a href="#原型和原型链的理解" class="headerlink" title="原型和原型链的理解"></a>原型和原型链的理解</h2><h2 id="vue和react的区别"><a href="#vue和react的区别" class="headerlink" title="vue和react的区别"></a>vue和react的区别</h2><h2 id="react中setState后发生了什么？"><a href="#react中setState后发生了什么？" class="headerlink" title="react中setState后发生了什么？"></a>react中setState后发生了什么？</h2><h2 id="shouldComponentUpdate作用"><a href="#shouldComponentUpdate作用" class="headerlink" title="shouldComponentUpdate作用"></a>shouldComponentUpdate作用</h2><h2 id="vue的keepAlive是什么"><a href="#vue的keepAlive是什么" class="headerlink" title="vue的keepAlive是什么"></a>vue的keepAlive是什么</h2><h2 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h2><h2 id="防抖和节流的使用场景和手写"><a href="#防抖和节流的使用场景和手写" class="headerlink" title="防抖和节流的使用场景和手写"></a>防抖和节流的使用场景和手写</h2><h2 id="Promise有何见解，手写一个包含promise-all-race-allSettled"><a href="#Promise有何见解，手写一个包含promise-all-race-allSettled" class="headerlink" title="Promise有何见解，手写一个包含promise.all race allSettled"></a>Promise有何见解，手写一个包含promise.all race allSettled</h2><h2 id="跨域和他的几个解决方法"><a href="#跨域和他的几个解决方法" class="headerlink" title="跨域和他的几个解决方法"></a>跨域和他的几个解决方法</h2><h2 id="javascript的值引用和值类型？涉及的深浅拷贝"><a href="#javascript的值引用和值类型？涉及的深浅拷贝" class="headerlink" title="javascript的值引用和值类型？涉及的深浅拷贝"></a>javascript的值引用和值类型？涉及的深浅拷贝</h2><h2 id="js中有哪些数据结构？v8引擎中对对象的优化？快慢对象优化？weakMap是什么？为什么可以很快被回收？"><a href="#js中有哪些数据结构？v8引擎中对对象的优化？快慢对象优化？weakMap是什么？为什么可以很快被回收？" class="headerlink" title="js中有哪些数据结构？v8引擎中对对象的优化？快慢对象优化？weakMap是什么？为什么可以很快被回收？"></a>js中有哪些数据结构？v8引擎中对对象的优化？快慢对象优化？weakMap是什么？为什么可以很快被回收？</h2><h2 id="http请求有哪些区别？是个什么流程，中间经过了哪些步骤？"><a href="#http请求有哪些区别？是个什么流程，中间经过了哪些步骤？" class="headerlink" title="http请求有哪些区别？是个什么流程，中间经过了哪些步骤？"></a>http请求有哪些区别？是个什么流程，中间经过了哪些步骤？</h2><h2 id="tcp三次握手四次挥手做了什么？中间会产生什么攻击，怎么防范？"><a href="#tcp三次握手四次挥手做了什么？中间会产生什么攻击，怎么防范？" class="headerlink" title="tcp三次握手四次挥手做了什么？中间会产生什么攻击，怎么防范？"></a>tcp三次握手四次挥手做了什么？中间会产生什么攻击，怎么防范？</h2><h2 id="tcp和udp有啥区别？应用场景分别是什么？"><a href="#tcp和udp有啥区别？应用场景分别是什么？" class="headerlink" title="tcp和udp有啥区别？应用场景分别是什么？"></a>tcp和udp有啥区别？应用场景分别是什么？</h2><h2 id="websocket是怎么实现的？"><a href="#websocket是怎么实现的？" class="headerlink" title="websocket是怎么实现的？"></a>websocket是怎么实现的？</h2><h2 id="http1-0和2和3的区别是什么？有什么不同？有哪些常用的状态吗？"><a href="#http1-0和2和3的区别是什么？有什么不同？有哪些常用的状态吗？" class="headerlink" title="http1.0和2和3的区别是什么？有什么不同？有哪些常用的状态吗？"></a>http1.0和2和3的区别是什么？有什么不同？有哪些常用的状态吗？</h2><h2 id="304时是什么缓存？http缓存是什么？协商缓存和强缓存有哪些区别？分别是怎么工作的？什么时候用什么？由什么字段控制？"><a href="#304时是什么缓存？http缓存是什么？协商缓存和强缓存有哪些区别？分别是怎么工作的？什么时候用什么？由什么字段控制？" class="headerlink" title="304时是什么缓存？http缓存是什么？协商缓存和强缓存有哪些区别？分别是怎么工作的？什么时候用什么？由什么字段控制？"></a>304时是什么缓存？http缓存是什么？协商缓存和强缓存有哪些区别？分别是怎么工作的？什么时候用什么？由什么字段控制？</h2><h2 id="http常用的请求头有哪些？"><a href="#http常用的请求头有哪些？" class="headerlink" title="http常用的请求头有哪些？"></a>http常用的请求头有哪些？</h2><h2 id="fetch请求两次是为什么？OPTIONS预检请求是什么？"><a href="#fetch请求两次是为什么？OPTIONS预检请求是什么？" class="headerlink" title="fetch请求两次是为什么？OPTIONS预检请求是什么？"></a>fetch请求两次是为什么？OPTIONS预检请求是什么？</h2><h2 id="SSL加密的原理？还有哪些常用的加密手段？AES对称加密和RSA非对称加密算法是如何使用的？"><a href="#SSL加密的原理？还有哪些常用的加密手段？AES对称加密和RSA非对称加密算法是如何使用的？" class="headerlink" title="SSL加密的原理？还有哪些常用的加密手段？AES对称加密和RSA非对称加密算法是如何使用的？"></a>SSL加密的原理？还有哪些常用的加密手段？AES对称加密和RSA非对称加密算法是如何使用的？</h2><h2 id="ajax的优缺点，原理？"><a href="#ajax的优缺点，原理？" class="headerlink" title="ajax的优缺点，原理？"></a>ajax的优缺点，原理？</h2><h2 id="axios-原理是什么？"><a href="#axios-原理是什么？" class="headerlink" title="axios 原理是什么？"></a>axios 原理是什么？</h2><h2 id="如何进行xss攻击？如何防范？如何进行csrf攻击？如何防范"><a href="#如何进行xss攻击？如何防范？如何进行csrf攻击？如何防范" class="headerlink" title="如何进行xss攻击？如何防范？如何进行csrf攻击？如何防范"></a>如何进行xss攻击？如何防范？如何进行csrf攻击？如何防范</h2><h2 id="网络层攻击有哪些？tcp报文攻击？udp报文攻击？ICMP报文攻击？"><a href="#网络层攻击有哪些？tcp报文攻击？udp报文攻击？ICMP报文攻击？" class="headerlink" title="网络层攻击有哪些？tcp报文攻击？udp报文攻击？ICMP报文攻击？"></a>网络层攻击有哪些？tcp报文攻击？udp报文攻击？ICMP报文攻击？</h2><p><a href="https://cshihong.github.io/2019/05/14/%E7%BD%91%E7%BB%9C%E5%B1%82-TCP-UDP-%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%8E%9F%E7%90%86/">网络层(TCP/UDP)攻击与防御原理</a></p><h2 id="应用层攻击有哪些？dns报文攻击？HTTP报文攻击？其他的Flood攻击？"><a href="#应用层攻击有哪些？dns报文攻击？HTTP报文攻击？其他的Flood攻击？" class="headerlink" title="应用层攻击有哪些？dns报文攻击？HTTP报文攻击？其他的Flood攻击？"></a>应用层攻击有哪些？dns报文攻击？HTTP报文攻击？其他的Flood攻击？</h2><p><a href="https://cshihong.github.io/2019/05/14/%E5%BA%94%E7%94%A8%E5%B1%82-DNS-HTTP-HTTPS-%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%8E%9F%E7%90%86/">应用层(DNS/HTTP/HTTPS)攻击与防御原理</a></p><h2 id="SPA应用首屏加载慢的优化方案"><a href="#SPA应用首屏加载慢的优化方案" class="headerlink" title="SPA应用首屏加载慢的优化方案"></a>SPA应用首屏加载慢的优化方案</h2><h2 id="css中link和-import的区别？"><a href="#css中link和-import的区别？" class="headerlink" title="css中link和@import的区别？"></a>css中link和@import的区别？</h2><h2 id="bind，apply和call的区别，手写一个"><a href="#bind，apply和call的区别，手写一个" class="headerlink" title="bind，apply和call的区别，手写一个"></a>bind，apply和call的区别，手写一个</h2><h2 id="this的指向问题？他的本质是什么？EC-AO-VO，浏览器底层是如何进行变量制造和上下文处理的？作用域链是什么？"><a href="#this的指向问题？他的本质是什么？EC-AO-VO，浏览器底层是如何进行变量制造和上下文处理的？作用域链是什么？" class="headerlink" title="this的指向问题？他的本质是什么？EC AO VO，浏览器底层是如何进行变量制造和上下文处理的？作用域链是什么？"></a>this的指向问题？他的本质是什么？EC AO VO，浏览器底层是如何进行变量制造和上下文处理的？作用域链是什么？</h2><h2 id="vue中的data为什么使用return直接data对象为什么不行"><a href="#vue中的data为什么使用return直接data对象为什么不行" class="headerlink" title="vue中的data为什么使用return直接data对象为什么不行"></a>vue中的data为什么使用return直接data对象为什么不行</h2><p><em>data 必须是一个函数</em><br>&nbsp;&nbsp;当我们定义这个<code>&lt;button-counter&gt;</code>组件时，你可能会发现它的 data 并不是像这样直接提供一个对象：</p><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span>: &#123;</span><span class="hljs-class">  <span class="hljs-title">count</span>: 0</span><span class="hljs-class">&#125;</span></code></pre><p>取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：</p><pre><code class="hljs ada">data: <span class="hljs-keyword">function</span> <span class="hljs-title"></span>() &#123;  <span class="hljs-keyword">return</span> <span class="hljs-type">&#123;</span>    count: <span class="hljs-number">0</span>  &#125;&#125;</code></pre><p>如果 Vue 没有这条规则，点击一个按钮就会影响到其它所有使用了该按钮实例</p><h2 id="typeof和instacneof的区别"><a href="#typeof和instacneof的区别" class="headerlink" title="typeof和instacneof的区别"></a>typeof和instacneof的区别</h2><h2 id="外边距重叠的问题？"><a href="#外边距重叠的问题？" class="headerlink" title="外边距重叠的问题？"></a>外边距重叠的问题？</h2><h2 id="seo优化？"><a href="#seo优化？" class="headerlink" title="seo优化？"></a>seo优化？</h2><h2 id="new操作符做了什么"><a href="#new操作符做了什么" class="headerlink" title="new操作符做了什么"></a>new操作符做了什么</h2><h2 id="面向过程编程是什么-和面向对象有什么区别？"><a href="#面向过程编程是什么-和面向对象有什么区别？" class="headerlink" title="面向过程编程是什么 和面向对象有什么区别？"></a>面向过程编程是什么 和面向对象有什么区别？</h2><h2 id="什么是ssr？有做过吗？有什么困难"><a href="#什么是ssr？有做过吗？有什么困难" class="headerlink" title="什么是ssr？有做过吗？有什么困难"></a>什么是ssr？有做过吗？有什么困难</h2><h2 id="箭头函数和普通函数区别？"><a href="#箭头函数和普通函数区别？" class="headerlink" title="箭头函数和普通函数区别？"></a>箭头函数和普通函数区别？</h2><h2 id="Page-Visibility-API用途？"><a href="#Page-Visibility-API用途？" class="headerlink" title="Page Visibility API用途？"></a>Page Visibility API用途？</h2><h2 id="HTML5新的特性？"><a href="#HTML5新的特性？" class="headerlink" title="HTML5新的特性？"></a>HTML5新的特性？</h2><h2 id="CSS3新特性？"><a href="#CSS3新特性？" class="headerlink" title="CSS3新特性？"></a>CSS3新特性？</h2><h2 id="px，em，rem的区别？1px解决方案"><a href="#px，em，rem的区别？1px解决方案" class="headerlink" title="px，em，rem的区别？1px解决方案"></a>px，em，rem的区别？1px解决方案</h2><h2 id="BFC（块级格式化上下文）的理解"><a href="#BFC（块级格式化上下文）的理解" class="headerlink" title="BFC（块级格式化上下文）的理解"></a>BFC（块级格式化上下文）的理解</h2><h2 id="script标签设置async或者defer的用处和区别？"><a href="#script标签设置async或者defer的用处和区别？" class="headerlink" title="script标签设置async或者defer的用处和区别？"></a>script标签设置async或者defer的用处和区别？</h2><h2 id="浏览器加载资源时的顺序和优化方案？"><a href="#浏览器加载资源时的顺序和优化方案？" class="headerlink" title="浏览器加载资源时的顺序和优化方案？"></a>浏览器加载资源时的顺序和优化方案？</h2><h2 id="居中有哪些方法？"><a href="#居中有哪些方法？" class="headerlink" title="居中有哪些方法？"></a>居中有哪些方法？</h2><h2 id="无限列表如何实现？复用和只是用一些dom"><a href="#无限列表如何实现？复用和只是用一些dom" class="headerlink" title="无限列表如何实现？复用和只是用一些dom"></a>无限列表如何实现？复用和只是用一些dom</h2><h2 id="浏览器事件机制是什么？冒泡和捕获？事件委托？分别是什么"><a href="#浏览器事件机制是什么？冒泡和捕获？事件委托？分别是什么" class="headerlink" title="浏览器事件机制是什么？冒泡和捕获？事件委托？分别是什么"></a>浏览器事件机制是什么？冒泡和捕获？事件委托？分别是什么</h2><h2 id="什么是点击穿透"><a href="#什么是点击穿透" class="headerlink" title="什么是点击穿透"></a>什么是点击穿透</h2>]]></content>
    
    
    <categories>
      
      <category>复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些想到的问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Event Loop解读（待完善）</title>
    <link href="/2020/11/25/browser/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2020/11/25/browser/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器Event-Loop"><a href="#浏览器Event-Loop" class="headerlink" title="浏览器Event Loop"></a>浏览器Event Loop</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section. Each agent has an associated event loop, which is unique to that agent.</p><p>要想了解浏览器的事件机制，我们需要知道，浏览器的线程基本概念</p><h3 id="浏览器进程线程"><a href="#浏览器进程线程" class="headerlink" title="浏览器进程线程"></a>浏览器进程线程</h3><p>浏览器中是多线程多进程的，我们每打开一个新的页面就会打开一个新的进程，每个进程中都会有多个线程在运作，其中常见的线程有以下几种：</p><ol><li>GUI渲染线程</li></ol><ul><li>负责页面渲染，处理HTML，CSS解析，DOM树的构建、布局和绘制；</li><li>当页面发生重绘重排时会重新调用此线程；</li><li>该线程和JS线程互斥，所以当GUI执行时，JS会被挂起，JS线程执行时，GUI会被挂起，直到任务队列空了，才会去执行GUI</li></ul><ol start="2"><li>JS线程</li></ol><ul><li>负责js代码的执行；</li><li>执行准备好的事件；</li></ul><ol start="3"><li>定时器线程</li></ol><ul><li>负责执行定时器任务例如：setTimeout,setInterval；</li><li>主线程执行遇到定时器任务时，将任务加入定时器线程，在计时完毕后，任务会加入任务队列，等待JS线程的执行</li></ul><ol start="4"><li>事件触发线程</li></ol><p>负责将准备好的事件添加到任务队列，等待JS线程执行</p><ol start="5"><li>异步请求线程</li></ol><p>负责执行异步请求一类的操作，如Promis，ajax，axios<br>主线程执行到了异步任务后，将任务讲给异步请求线程执行，执行完后，将回调函数添加到微任务队列，等待JS线程执行</p><h2 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h2><p><strong>浏览器中的Event-loop</strong><br>浏览器中的事件循环机制中有两中队列，一个是宏任务一个是微任务，当主线程遇到同步操作时加入宏任务，遇到异步操作时加入微任务。常见的宏任务：setTimeout,setInterval，script（整段代码），I/O操作，UI渲染常见的微任务：Promise.then,MutationObserver<br>&emsp;&emsp;其中的执行机制是当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。其中微任务是不打断的直接执行完一整个队列的任务。</p><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><h3 id="一些题目解读"><a href="#一些题目解读" class="headerlink" title="一些题目解读"></a>一些题目解读</h3><p>可以通过一个例子来进行分析：</p><ol><li><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script start&#x27;</span>);    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">await</span>  async2().then(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span><span class="hljs-built_in">console</span>.log(_));        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async1 return&#x27;</span>;    &#125;    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2 promise&#x27;</span>)).then(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2 then&#x27;</span>));        <span class="hljs-keyword">await</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2 await&#x27;</span>);        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2 end&#x27;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async2 return&#x27;</span>;    &#125;    async1().then(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span><span class="hljs-built_in">console</span>.log(_,<span class="hljs-string">&#x27;async1 then&#x27;</span>));    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;settimeout&#x27;</span>);    &#125;,<span class="hljs-number">0</span>);    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise&#x27;</span>);        resolve();    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;function1&#x27;</span>);    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;function2&#x27;</span>);    &#125;);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>)</code></pre>在这个例子里：</li></ol><ul><li>首先<strong>输出</strong><code>script start</code></li><li>然后是<code>async1</code>的内容，此刻<code>await</code>执行<code>async2</code><strong>输出</strong><code>async2 promise</code>,然后<code>then</code>进入微任务</li><li>然后下面的<code>await</code><strong>输出</strong><code>async2 await</code>，然后后面的阻塞，进入微任务</li><li>然后继续执行，<strong>输出</strong><code>promise</code>，<code>then</code>进入微任务</li><li>然后<strong>输出</strong><code>script end</code></li><li>此时宏任务执行完一轮</li><li>微任务开始执行，先<strong>输出</strong><code>async2 then</code>，<code>async2 end</code>，然后<code>return</code>值进入微任务，同一批次的微任务中继续执行<strong>输出</strong><code>function1</code>，然后<code>2then</code>又进入微任务</li><li>继续执行微任务，此时先<strong>输出</strong><code>async2 return</code>，然后<code>async1</code>的<code>await</code>后的进入微任务</li><li><strong>输出</strong><code>function2</code></li><li>在执行微任务<strong>输出</strong><code>async1 end</code>，然后<code>1return</code>进入<code>async1().then(_=&gt;console.log(_,&#39;async1 then&#39;));</code>的微任务</li><li><strong>输出</strong><code>async1 return</code>,<code>async1 then</code>，微任务为空，执行宏任务</li><li><strong>输出</strong><code>settimeout</code></li></ul><p>最终顺序为</p><pre><code class="hljs applescript"><span class="hljs-keyword">script</span> startasync2 promiseasync2 awaitpromise<span class="hljs-keyword">script</span> <span class="hljs-keyword">end</span>async2 <span class="hljs-keyword">then</span>async2 <span class="hljs-keyword">end</span>function1async2 <span class="hljs-literal">return</span>function2async1 <span class="hljs-keyword">end</span>async1 <span class="hljs-literal">return</span>async1 <span class="hljs-keyword">then</span>settimeout</code></pre><ol><li><pre><code class="hljs coffeescript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;e1&#x27;</span>)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(r,j)</span>=&gt;</span>&#123;r()&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise3&#x27;</span>);    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout3&#x27;</span>)    &#125;,<span class="hljs-number">0</span>)&#125;)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout1&#x27;</span>)    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(r,j)</span>=&gt;</span>&#123;r()&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)    &#125;)&#125;,<span class="hljs-number">5000</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;e2&#x27;</span>)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(r,j)</span>=&gt;</span>&#123;r(<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>))&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>);    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout2&#x27;</span>)    &#125;,<span class="hljs-number">0</span>)&#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;e3&#x27;</span>)</code></pre>在这个例子里：</li></ol><ul><li>主线程<code>main</code>进入栈执行操作，此时执行<code>script</code>代码，会把<strong>输出</strong><code>e1</code></li><li>之后遇到<code>Promise.then</code>，会将其加入微任务队列</li><li>再往下执行，遇到<code>setTimeout</code>，将其加入定时器线程，等待计数完成后加入宏任务队列</li><li>再往下执行<strong>输出</strong><code>e2</code></li><li>往下执行遇到<code>Promise</code>，先将<code>resolve</code>输出1，然后将<code>then</code>加入微任务队列</li><li>再往下执行<strong>输出</strong>e3，此时<code>script</code>代码执行完毕，立刻搜索微任务是否为空，不为空就立刻执行此时微任务的队列</li><li>此时微任务队列先进先出输出<code>promise3</code>，然后遇到<code>setTimeout</code>，将其加入定时器线程，等待计数完成后加入宏任务队列</li><li>再往下执行第二个微任务，输出<code>promise2</code>，然后遇到<code>setTimeout</code>，将其加入定时器线程，等待计数完成后加入宏任务队列</li><li>再往下执行发现微任务队列为空，去宏任务队列去寻找是否有任务</li><li>在宏任务发现此时先执行完的<code>setTimeout3</code>，输出<code>timeout3</code>，将<code>then</code>加入微任务队列</li><li>执行完该次宏任务后立刻寻找微任务队列，为空，去寻找宏任务队列</li><li>在宏任务发现先执行完的<code>setTimeout2</code>任务，执行<strong>输出</strong><code>timeout2</code></li><li>此时任务队列为空，等待新任务加入</li><li>此时<code>setTimeout1</code>计数完毕，加入宏任务队列，并执行，<strong>输出</strong><code>timeout1</code>，将<code>then</code>加入微任务队列</li><li>执行完该次宏任务后立刻寻找微任务队列，并执行，<strong>输出</strong><code>promise1</code><br>最终结果为<pre><code class="hljs mercury">e1 e2 <span class="hljs-number">1</span> e3 promise3 promise2 timeout3 timeout2 timeout1 <span class="hljs-keyword">promise</span></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器中的缓存方式</title>
    <link href="/2020/11/24/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F/"/>
    <url>/2020/11/24/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201130133052.png"></p><h2 id="浏览器缓存（http缓存）"><a href="#浏览器缓存（http缓存）" class="headerlink" title="浏览器缓存（http缓存）"></a>浏览器缓存（http缓存）</h2><p>&emsp;&emsp;先看看浏览器发起请求和，内部是个什么流程：<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201130152153.png"><br>&emsp;&emsp;如图，浏览器会先问自己有没有缓存，缓存是否过期了，然后去问服务器关于资源的问题。如此我们先解决第一个问题，浏览器自己的缓存是放在什么地方了。<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201130152429.png"><br>&emsp;&emsp;从浏览器的<code>network</code>里可以看到资源会放在<code>memory cache</code>和<code>disk cache</code>里。</p><h3 id="memory-cache-和-disk-cache"><a href="#memory-cache-和-disk-cache" class="headerlink" title="memory cache 和 disk cache"></a>memory cache 和 disk cache</h3><h4 id="memory-cache"><a href="#memory-cache" class="headerlink" title="memory cache"></a>memory cache</h4><p>顾名思义，就是将资源缓存到<em>内存</em>中，等待下次访问时不需要重新下载资源，而直接从内存中获取。<code>Webkit</code>早已支持<code>memoryCache</code>。目前<code>Webkit</code>资源分成两类</p><ul><li>一类是<strong>主资源</strong>，比如<em>HTML页面</em>，或者<em>下载项</em></li><li>一类是<strong>派生资源</strong>，比如HTML页面中内嵌的<em>图片</em>或者<em>脚本链接</em></li></ul><p>分别对应代码中两个类：<code>MainResourceLoader</code>和<code>SubresourceLoader</code>。虽然<code>Webkit</code>支持<code>memoryCache</code>，但是也只是针对派生资源，它对应的类为<code>CachedResource</code>，用于保存原始数据（比如<code>CSS，JS</code>等），以及解码过的图片数据。</p><h4 id="diskCache"><a href="#diskCache" class="headerlink" title="diskCache"></a>diskCache</h4><p>顾名思义，就是将资源缓存到<em>磁盘</em>中，等待下次访问时不需要重新下载资源，而直接从磁盘中获取，它的直接操作对象为<code>CurlCacheManager</code>。它与<code>memoryCache</code>最大的区别在于，<strong>当退出进程时，内存中的数据会被清空，而磁盘的数据不会</strong>，所以，当下次再进入该进程时，该进程仍可以从<code>diskCache</code>中获得数据，而<code>memoryCache</code>则不行。<code>diskCache</code>与<code>memoryCache</code>相似之处就是也只能存储一些派生类资源文件。它的存储形式为一个index.dat文件，记录存储数据的<code>url</code>，然后再分别存储该<code>url</code>的<code>response</code>信息和<code>content</code>内容。<code>Response</code>信息最大作用就是利用<code>Last-Modified</code>等标记来判断服务器上该<code>url</code>的<code>content</code>内容是否被修改。</p><h4 id="读取缓存的优先级"><a href="#读取缓存的优先级" class="headerlink" title="读取缓存的优先级"></a>读取缓存的优先级</h4><ol><li>先看内存有没有，有就直接加载</li><li>没有就在看磁盘有没有，有就直接加载</li><li>还没有就只能访问网络请求拿数据</li><li>拿到后存到对应的地方</li></ol><h3 id="浏览器缓存分类"><a href="#浏览器缓存分类" class="headerlink" title="浏览器缓存分类"></a>浏览器缓存分类</h3><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>&emsp;&emsp;强缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。<br>缓存是否存在取决的我们是否<em>缓存了</em>和是否<em>有效期过了</em>，这里就涉及到两个头字段的属性了。</p><ul><li>Expires</li></ul><p>该字段是 <code>http1.0</code> 时的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如Expires:Mon, 30 Nov 2020 02:23:37 GMT。这个时间代表着这个资源的<em>失效时间</em>，在此时间之前，就可以命中缓存。但是这种方式有较大的问题，因为是利用时间戳进行判断的，一旦系统的时间有问题，就会出现缓存混乱的问</p><ul><li>Cache-Control</li></ul><p><code>Cache-Control</code> 是<code>http1.1</code>时出现的<code>header</code>信息，主要是利用该字段的 <code>max-age</code>值来进行判断，它是一个相对时间，例如<code>Cache-Control:max-age=3600</code>，代表着资源的有效期是3600秒。</p><p>&emsp;&emsp;此外，<code>cache-control</code>除了<code>max-age</code>字段外，还有下面几个比较常用的设置值：</p><ul><li>no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。</li><li>no-store：禁止使用缓存，每一次都要重新请求数据。</li><li>public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</li><li>private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</li></ul><p>&emsp;&emsp;<code>Cache-Control</code>与<code>Expires</code>可以在服务端配置同时启用，同时启用的时候 <code>Cache-Control</code> <strong>优先级高</strong>。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>&emsp;&emsp;协商缓存浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。<br>&emsp;&emsp;其中<code>header</code>中的缓存标识有：<code>if-Modified/if-Modified-Since</code>和<code>Etag/if-none-match</code>，其中<code>Etag/if-none-match</code>会先被服务器验证，之后再去查验<code>if-Modified</code>的情况</p><ul><li>if-Mif-Modifiedif-Modified/if-Modified-Since<br>第一次请求一个资源的时候，服务器会在头部加上<code>if-Modified</code>字段来告诉浏览器最后一次修改的时间什么时候。然后浏览器再次请求相同资源时，会附加<code>if-Modified-Since</code>字段，该字段为之前<code>if-Modified</code>的值，服务器据此判断资源是否被修改过，如果没变化，就返回<code>304</code>，告诉浏览器用之前的资源就好了，这资源咱就不再重复传了。</li><li>Etag/if-none-match<br>和上面情况相同，不过返回的值是一个<code>Etag</code>校验码，用来标识资源是否有变动，不过在确认没变化后除了返回<code>304</code>，还有传回一个<code>Etag</code>。<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201130155850.png"><br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201130155821.png"></li></ul><p><strong>PS:我个人认为当某些资源可能是长时间都不会有变动的时候，我们对他使用强缓存设置一个较长的过期时间，然后此类资源就可以在我们可控的范围内免去网络请求而直接在本地获取。如果某些资源变动的较为频繁，我们会去使用协商缓存来保证当服务器资源被修改后能立刻获取新资源，如果没有资源变动那么也可以省去重新下载的步骤。</strong></p><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>&emsp;&emsp;<code>Cookie</code> 是直接存储在浏览器中的一小串数据。它们是 <code>HTTP</code> 协议的一部分，由 <code>RFC 6265</code> 规范定义。<br>&emsp;&emsp;<code>Cookie</code> 通常是由 <code>Web</code> 服务器使用响应 <code>Set-Cookie HTTP-header</code> 设置的。然后浏览器使用 <code>Cookie HTTP-header</code> 将它们自动添加到（几乎）每个对相同域的请求中。<br>&emsp;&emsp;最常使用的就是登录验证，整个过程中，客户端登录后，服务器在响应中使用 <code>Set-Cookie HTTP-header</code> 来设置具有唯一“会话标识符<code>（session identifier）</code>的 <code>cookie</code>。下次如果请求是由相同域发起的，浏览器会使用<code>Cookie HTTP-header</code>通过网络发送 <code>cookie</code>。所以服务器就知道是谁发起了请求。</p><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>&emsp;&emsp;<code>sessionStorage</code>属性允许你访问一个，对应当前源的<code>session Storage</code>对象。它与<code>localStorage</code>相似，不同之处在于<code>localStorage</code>里面存储的数据没有过期时间设置，而存储在 <code>sessionStorage</code> 里面的数据在页面会话结束时会被清除。</p><ul><li><p>页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话</p></li><li><p>在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，这点和 session cookies 的运行方式不同</p></li><li><p>打开多个相同的URL的Tabs页面，会创建各自的sessionStorage。</p></li><li><p>关闭对应浏览器窗口（Window）/ tab，会清除对应的sessionStorage。</p><h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h3><p>&emsp;&emsp;<code>localStorage</code> 最主要的特点是：</p></li><li><p>在同源的所有标签页和窗口之间共享数据。</p></li><li><p>数据不会过期。它在浏览器重启甚至系统重启后仍然存在。</p></li></ul><p>&emsp;&emsp;只读的<code>localStorage</code>属性允许你访问一个<code>Document</code>源（origin）的对象 <code>Storage</code>；存储的数据将保存在浏览器会话中。<code>localStorage</code> 类似 <code>sessionStorage</code>，但其区别在于：存储在 <code>localStorage</code> 的数据可以长期保留；而当页面被关闭时，存储在 <code>sessionStorage</code> 的数据会被清除。<br>&emsp;&emsp;无论数据存储在 <code>localStorage</code> 还是 <code>sessionStorage</code> ，它们都特定于页面的协议。另外，<code>localStorage</code> 中的<strong>键值对总是以字符串的形式存储</strong>。 (需要注意, 和js对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型).</p><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p>&emsp;&emsp;<code>IndexedDB</code> 是一个用于在浏览器中储存较大数据结构的 Web API, 并提供<strong>索引功能</strong>以实现高性能查找. 像其他基于 <code>SQL</code> 的 关系型数据库管理系统 (RDBMS) 一样, <code>IndexedDB</code> 是一个事务型的数据库系统. 然而, 它是使用 JavaScript 对象而非列数固定的表格来储存数据的.它比 <code>localStorage</code> 强大得<br>多。</p><ul><li>通过键和多种键的类型来存储几乎任何类型的值。</li><li>支撑事务的可靠性</li><li>支持键范围查询、索引</li><li>和 localStorage 相比，它可以存储更大的数据量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http协议初解</title>
    <link href="/2020/11/23/network/http%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/11/23/network/http%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="http概述"><a href="#http概述" class="headerlink" title="http概述"></a>http概述</h2><p>&emsp;&emsp;<strong>超文本传输协议</strong><code>HTTP</code>是分布式、协作的、超媒体信息系统的应用层协议。它是通用的，<em><strong>无状态</strong></em>的协议，可以用在超文本用途之外的许多任务，如名称服务器和分布式目标管理系统，通过扩展它的请求方法，错误码和头部。HTTP的一个特性是数据表示的引入和协商，允许系统建立独立的传输数据。<br>&emsp;&emsp;我们就这个名字<strong>超文本传输协议</strong>进行分析，可以解构为<em>超文本</em>，<em>传输</em>，<em>协议</em></p><ol><li>超文本<br>什么是超文本？超越文本的内容就是超文本，早期的计算机是以文字进行传输的，后来的极速发展导致更多形式的数据可以进行传输，图像视频音频等，所以这些“文本”就被称为<strong>超文本</strong>；</li><li>传输<br>我们要进行终端与终端间的传输，我们需要把文本转成二进制通过物理链路进行传输，其中双方还需要对传输进行响应，才能达到传输的目的<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/1606103485414.jpg" alt="传输模型"></li><li>协议<br>计算机之间通信需要互相遵循的规则，就是网络协议。http协议就是一种计算机之间通信的的规范和约束。<h2 id="计算机网络协议模型"><a href="#计算机网络协议模型" class="headerlink" title="计算机网络协议模型"></a>计算机网络协议模型</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3>&emsp;&emsp;ISO（国际标准化组织）提出来计算机网络应该按照7层来组织，于是诞生了OSI七层模型。<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201123130249.png" alt="七层模型"><br>我们从上往下看这七层模型都发挥了什么作用：</li></ol><ul><li><strong>应用层</strong><br>特定网络应用协议存放的一层，为我们特定的网络应用提供服务我们平时的超文本传输协议<code>HTTP</code>，电子邮件传输的<code>SMTP</code>，文件传输的<code>FTP</code>，域名解析的<code>DNS</code>等等。</li><li><strong>表示层</strong><br>主要对数据的操作，对数据进行加密、压缩或者描述，负责把下一层传来的数据转换成应用层能够使用的数据形式，把应用层的数据转换成适合网络传输的格式。</li><li><strong>会话层</strong><br>为不同机器间创建和管理会话的一层</li><li><strong>传输层</strong><br>传输层是承上启下的一层，下三层主要是进行数据的传输，上三层主要进行数据的处理，传输层主要就是建立正确的端到端的通信，确保保文的正确传输，该层主要有两种协议，分别是可靠传输<code>TCP</code>和不可靠的<code>UDP</code>。<ul><li>TCP：一种面向连接的、可靠的、基于字节流的传输层通信协议（TCP，Transmission Control Protocol），建立通信前会先建立一个TCP连接，类似于打电话中的“喂，你是xxx吗”，回答“我是xxx”，通过三次握手建立稳定的连接，在结束连接是会进行四次挥手断开连接。<br>&emsp;&emsp;在TCP协议中会通过对数据进行检验确保数据的正确性和合法性，通过超时重传的方式保证连接的可靠性，通过用拥塞控制算法（AIMD算法）实现对网络传输的控制，通过滑动窗口的方式达到流量控制的目的。</li><li>UDP：一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的IP数据包的方法.<br>&emsp;&emsp;由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。正是因为UDP在传输数据前不建立连接，不对数据报进行检查与修改，无须等待对方的应答，所以会出现分组丢失、重复、乱序，应用程序需要负责传输可靠性方面的所有工作。也正是因此，UDP具有较好的实时性，工作效率较TCP协议高；而且因为UDP段结构比TCP的段结构简单，因此网络开销也小。很适合分发信息的操作，哪怕信息错误，很快就会被新的信息替代，平时的实时视频音频大多会使用UDP。</li></ul></li><li><strong>网络层</strong><br>负责在网络中找到合适的路径抵达我们的目标网络，通过路由算法和寻址等方法建立起合适的路径。</li><li><strong>链路层</strong><br>数据链路层就是实现物理信号和数据帧转化，接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</li><li><strong>物理层</strong><br>物理层的主要功能就是利用传输介质(例如：网线，无线电波，光)为数据链路层提供物理连接，实现比特流的透明传输。<br>&emsp;&emsp;以上，建立在该网络模型之上，HTTP可以实现两点之间文字视频等超文本数据的传输。<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201123130640.png"><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3>&emsp;&emsp;在TCP/IP中会话层和表示层被放在了应用层中，其他层主要内容是一样的。<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201125092256.png" alt="TCP四层"><br>&emsp;&emsp;其上的两层分别是以下内容，其他层作用一样。</li><li><strong>应用层</strong><br>主要有负责web浏览器的HTTP协议， 文件传输的FTP协议，负责电子邮件的SMTP协议，负责域名系统的DNS等。</li><li><strong>传输层</strong><br>主要是有可靠传输的TCP协议，特别高效的UDP协议。主要负责传输应用层的数据包。</li></ul><h2 id="HTTP工作流程"><a href="#HTTP工作流程" class="headerlink" title="HTTP工作流程"></a>HTTP工作流程</h2><p><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201123204750.png"><br>一次HTTP操作称为一次事务，可以分为四步：<br>1、首先客户和服务器需要建立连接，用户点击一个链接或者发出一次请求，HTTP请求开始工作<br>2、建立连接成功后，客户发送一个HTTP请求给服务器</p><ul><li>HTTP请求组成：请求行、消息报头、请求正文，<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201124113415.png"></li><li>请求的内容是以一个方法符号开头，后面跟着请求的<code>URL</code>、协议版本号、客户信息等别的可能的内容</li></ul><p><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201124113416.png"><br>3、服务器收到请求后，给予相应的响应信息</p><ul><li>HTTP响应组成：状态行、消息报头、响应正文。</li><li>内容包括：服务器HTTP协议的版本，服务器发回的响应状态代码和状态代码的文本描述、服务器信息等别的可能的内容<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201124113711.png"></li></ul><p>4、客户端收到服务器返回的信息通过浏览器显示在用户的显示屏上，确定没问题后断开连接</p><p>其中HTTP请求后返回的状态码不同的开头数字分别代表了不同的意义</p><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。状态代码的第一个数字代表当前响应的类型：</p><table><thead><tr><th align="center">状态码</th><th align="center">类别</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">1xx</td><td align="center">消息</td><td align="center">请求已被服务器接收，继续处理</td></tr><tr><td align="center">2xx</td><td align="center">成功</td><td align="center">请求已成功被服务器接收、理解、并接受</td></tr><tr><td align="center">3xx</td><td align="center">重定向</td><td align="center">需要后续操作才能完成这一请求</td></tr><tr><td align="center">4xx</td><td align="center">请求错误</td><td align="center">请求含有词法错误或者无法被执行</td></tr><tr><td align="center">5xx</td><td align="center">服务器错误</td><td align="center">服务器在处理某个正确请求时发生错误</td></tr></tbody></table><p>虽然<code>RFC 2616</code>中已经推荐了描述状态的短语，例如<code>200 OK</code>，<code>404 Not Found</code>，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。<br>&emsp;&emsp;关于状态码，有些有意思的图解，虽然有些味道，但是描述的还挺形象的。<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201124161902.png"></p><h2 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h2><p>TCP的建立连接断开连接是通过三次握手四次挥手实现的，要理解这种连接方式，我们需要先知道<strong>TCP报头</strong>的组成方式，如下如所示：<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201123203435.png"><br>其中比较重要的就是序号、确认号和标识位：</p><ol><li>序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</li><li>确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。（千万不要与标志位中的ACK搞混，这两个不是一个东西）</li><li>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：<ul><li>URG：紧急指针（urgent pointer）有效。</li><li>ACK：确认序号是否有效，一般置为1。</li><li>PSH：提示接收端应用程序立即从 TCP 缓冲区把数据读走。接收方应该尽快将这个报文交给应用层。</li><li>RST：重置连接。对方要求重新建立连接，复位。</li><li>SYN：请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为 1</li><li>FIN：释放一个连接。</li></ul></li></ol><p>&emsp;&emsp;<strong>三次握手四次挥手流程</strong><br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/20201124115039.png"><br>&emsp;&emsp;我们详细解读一下这个图的流程：</p><ol><li><strong>第一次握手：</strong><br>首先，客户端发出请求，请求的标志符<code>SYN</code>为1，随意生成一个seq序号，告诉服务器“我想建立连接”，此时客户端进入<code>SYN_SENT</code>已发送阶段</li><li><strong>第二次握手：</strong><br>服务器收到请求后，从<code>LISTEN</code>状态转成<code>SYN_RCVO</code>已收到阶段，然后发回请求，请求的标志符<code>SYN</code>为1，<code>ACK</code>为客户端的seq序号+1，确认是否之前的请求有效，随意生成的一个seq序号，告诉客户端“我同意连接，你准备好连接了吗”</li><li><strong>第三次握手：</strong><br>客户端收到服务器确认后，进入<code>ESTABLISHED</code>已连接状态，然后发回请求，标志符<code>ACK</code>为服务器的seq序号+1，告诉服务器“我准备好连接了”，服务器收到后也进入<code>ESTABLISHED</code>已连接状态</li><li>自此正式建立连接，进行正常的数据交互</li><li><strong>第一次挥手：</strong><br>结束数据交互后，要结束连接，此时客户端发送<code>FIN</code>告诉服务器“我要结束连接了”，并进入<code>FIN-WAIT-1</code>终止等待1状态</li><li><strong><em>第二次挥手：</em></strong><ul><li>服务器收到请求后，立刻发出<code>ACK</code>标志的确认请求，告诉客户端“我知道了”，此时客户端进入<code>FIN-WAIT-2</code>终止等待2状态，等待服务器发出连接释放的请求。</li><li>随后服务器进入<code>CLOSEWAIT</code>（关闭等待）状态，TCP进程去询问应用层是否没有数据要传输了，此刻如果有数据那么依旧会进行数据传输，客户端也会接收，</li></ul></li><li><strong>第三次挥手：</strong><br>当服务器知道没有数据要发送时，发送<code>FIN</code>报文，告知客户端“要断开连接了”，此时服务器进入<code>LAST-ACK</code>最后确认状态</li><li><strong>第四次挥手：</strong><br>客户端收到报文后，立刻发出确认报文，告知“已知晓”，然后进入<code>TIME_WAIT</code>时间等待状态，在结束时间等待后才会彻底释放TCP连接，至此整个TCP连接完成。</li></ol><h2 id="HTTP的优劣"><a href="#HTTP的优劣" class="headerlink" title="HTTP的优劣"></a>HTTP的优劣</h2><p>言归正传，我们来看看HTTP协议的优点和缺点：</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>HTTP的优势很明显，如下几个是比较突出的：</p><ol><li>简单灵活易扩展<br>因为HTTP的只规定了基本格式，空格分隔单词，换行分隔字段等。其他地方部分都可以由开发者自由定义，所以特别的灵活易扩展</li><li>可靠传输<br>因为使用了TCP/IP，所以继承了TCP，具备可靠传输的特性。</li><li>无状态<br>因为服务器不需要记忆这些状态，所以既能减轻服务器负担又能简化请求。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>同时HTTP也有一下缺点：</p><ol><li>无状态<br>因为无状态，所以无法处理连续事务，不过服务端也发展出了<code>Cookie</code>来进行记录。</li><li>明文传输<br>因为HTTP的明文传输，所以很容易被人截获具体内容，非常不安全。</li><li>队头阻塞<br>因为HTTP的采用了TCP协议，所以一旦某个连接很长，那么会导致其他连接被阻塞。</li></ol><h2 id="HTTP各版本的区别"><a href="#HTTP各版本的区别" class="headerlink" title="HTTP各版本的区别"></a>HTTP各版本的区别</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h3><p>&emsp;&emsp;HTTP0.9的主要内容<br>&emsp;&emsp;1991年,原型版本，功能简陋，只有一个命令GET,只支持纯文本内容，该版本已过时。</p><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><p>&emsp;&emsp;HTTP1.0的主要内容</p><ul><li>任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。</li><li>除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令。</li><li>http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。只使用 <code>header</code> 中的 <code>If-Modified-Since</code> 和 <code>Expires</code> 作为缓存失效的标准。</li><li>不支持断点续传，也就是说，每次都会传送全部的页面和数据。</li><li>通常每台计算机只能绑定一个 <code>IP</code>，所以请求消息中的 <code>URL</code> 并没有传递主机名<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3>HTTP1.1的主要内容</li><li>http1.1是目前最为主流的http协议版本，从1999年发布至今，仍是主流的http协议版本。</li><li>引入了<strong>持久连接</strong>（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，默认是<code>Connection: keep-alive</code>，即开启，设置<code>Connection: close</code>手动关闭。配合<code>Keep-Alive: timeout=5, max=1000</code>来设定连接时长。其中timeout指定一个空闲连接需要保持打开状态而最小时长（单位：秒）。max指定此次连接的最大请求数。</li><li>引入了<strong>管道机制</strong>（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率，会造成队头阻塞。</li><li>HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match，If-None-Match 等缓存控制标头来控制缓存失效。</li><li>支持断点续传，通过使用请求头中的 Range 来实现。</li><li>使用了<strong>虚拟网络</strong>，因为在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。所以HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</li><li>新增方法：PUT、 PATCH、 OPTIONS、 DELETE。</li></ul><p><strong>HTTP1.*的<em>主要问题</em></strong></p><ol><li>因为持久连接的缘故，如果某些文件频繁的被请求，那么keep-alive导致了文件被请求之后还保持了不必要的连接很长时间，这会使得使得服务器性能下降。</li><li>因为管道的机制，所以所有的通信都是在管道内按序进行的，一旦某个连接持续时间过久，会导致整体任务被阻塞，这就是队头阻塞。<br>&emsp;&emsp;<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3></li></ol><ul><li>二进制分帧<br>这是一次彻底的二进制协议，以二进制代替原本的明文传输，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧。</li><li>头部压缩<br>HTTP 1.1版本会出现 <code>「User-Agent、Cookie、Accept、Server、Range」</code> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 <code>HPACK</code> 算法进行压缩。</li><li>多路复用<br>复用TCP连接，不断的发帧，每帧的<code>stream identifier</code>都标明这一帧属于哪个流，然后在对方接收时，根据<code>stream identifier</code>拼接每个流的所有帧组成一整块数据。把HTTP/1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应分成多个帧，这样都个连接可以在一个连接里实现数据交换，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题、减少了TCP连接数，同时解决的TCP慢启动的问题。</li><li>服务器推送<br>允许服务器未经请求，主动向客户端发送资源，即服务器推送。<ul><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li></ul></li><li>请求优先级<br>可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li></ul><p>综上，大致是HTTP的各个版本的一些特点和TCP的连接形式，在HTTP上还有一个HTTPS，虽然他只是在HTTP上套了一层加密，涉及了密码学、TLS/SSL，所以其中的门道也不少，可惜这里地方太小写不下了。</p><p>参考：<br>[1]<a href="https://juejin.cn/post/6857287743966281736#heading-27">https://juejin.cn/post/6857287743966281736#heading-27</a><br>[2]<a href="https://juejin.cn/post/6844903667569541133#heading-35">https://juejin.cn/post/6844903667569541133#heading-35</a></p>]]></content>
    
    
    <categories>
      
      <category>http</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器概述</title>
    <link href="/2020/11/23/browser/%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/11/23/browser/%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="现代浏览器历史"><a href="#现代浏览器历史" class="headerlink" title="现代浏览器历史"></a>现代浏览器历史</h2><ul><li>1990年：蒂姆伯纳斯李开发了第一个网页浏览器WorldWideWeb，后来改名为Nexus。WorldWideWeb浏览器支持早期的HTMl标记语言，很简单，只支持文本、简单的样式表、电影、声音、图片等资源的显示。</li><li>1993年：马克安德森领导的团队开发了第一个具有影响力的浏览器Mosaic，这就是后来有名的Netscape Navigator。</li><li>1995年：微软推出了Internet Explorer，内置在windows系统中，和Netscape展开了第一次浏览器大战。</li><li>1998年：Netscape公司因为微软的商业策略市场份额下降，随后开放了Netscape Navigator源代码，成立了Mozilla基金会，之后开启了第二次浏览器大战。同年1998年11月24日，美国在线（AOL）宣布将以42亿美元的免税股票交换方式收购Netscape Communications。</li><li>2003年：苹果公司发布了Safari浏览器，时代华纳（前美国在线时代华纳）解散了Netscape。</li><li>2005年：苹果公司开源了浏览器中的核心代码，基于此发起了一个新的开源项目Webkit</li><li>2008年：谷歌以WebKit内核创建了一个新的浏览器项目Chromium，以此发布了Chrome浏览器。</li></ul><ol><li>现代浏览器的特征</li></ol><ul><li>网络</li><li>资源管理</li><li>网页浏览</li><li>多页面管理</li><li>插件和拓展</li><li>账户和同步</li><li>安全机制</li><li>开发者工具</li></ul><ol start="2"><li>现代浏览器的结构</li></ol><ul><li>用户界面（User Interface）</li><li>浏览器引擎（Browser Engine）</li><li>渲染引擎（Rendering Engine）</li><li>网络（Networking）</li><li>XML解析器（XML Parser）</li><li>显示后端（Display Backend）</li><li>数据持久层（Data Persistence）<br><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/liulanqi.png"></li></ul><ol><li>常见的渲染引擎<table><thead><tr><th>渲染引擎</th><th>浏览器</th></tr></thead><tbody><tr><td>Trident</td><td>IE、Edge(旧)</td></tr><tr><td>Gecko</td><td>Firefox</td></tr><tr><td>WebKit</td><td>Safari</td></tr><tr><td>Blink(WebKit fork)</td><td>Chromium/Chrome/Opera/Edge</td></tr></tbody></table></li></ol><h2 id="渲染引擎结构和工作流程"><a href="#渲染引擎结构和工作流程" class="headerlink" title="渲染引擎结构和工作流程"></a>渲染引擎结构和工作流程</h2><h3 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h3><p><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/render.png"><br>结合这张渲染引擎的过程，可以得知</p><ul><li>通过HTML/JavaScript/CSS等文件作为输入–&gt;</li><li>解析HTML转换成DOM Tree，把HTML的标签啥的转成DOM树的节点–&gt;</li><li>根据CSS的渲染规则和DOM树关联起来生成渲染树Render Tree–&gt;</li><li>根据渲染树生成布局树Layout of Render Tree–&gt;</li><li>最后绘制渲染树–&gt;</li><li>展示页面<h3 id="每步详细流程"><a href="#每步详细流程" class="headerlink" title="每步详细流程"></a>每步详细流程</h3><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/render2.png"><br>三大件的代码进入浏览器之后，会通过HTML解析器、CSS解析器、JavaScript解释器，最终生成最后的渲染树给到Layout去进行布局树的构建，最后通过最终的Tree进行Painting绘制得到最后的页面。<br>其中因为Javascript可以操作CSS和DOM元素，所以JavaScript可以打断整个流程，所以<strong>我们最好是把JavaScript放在整个页面的最后来执行</strong>。<br>当其中的<strong>DOM发生变化后，整个RenderTree和Layout of Render Tree都要重新生成，然后重新绘制</strong>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器同源策略</title>
    <link href="/2020/11/22/browser/%E8%B7%A8%E5%9F%9F/"/>
    <url>/2020/11/22/browser/%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h2><p>&emsp;&emsp;同源策略（<code>Same origin policy</code>）是指在Web浏览器中，允许某个网页脚本访问另外一个网页的数据，但前提是这两个网页必须有相同的URL、主机名和端口号，一旦两个网站满足以上条件，这两个网站就被认定为具有相同来源。此策略可防止某个网页上的恶意脚本通过该页面的文档对象模型访问另一个网页上的敏感数据。</p><table><thead><tr><th align="center">URL</th><th align="center">说明</th><th align="center">是否通讯</th></tr></thead><tbody><tr><td align="center"><a href="http://www.abc.com/a.js">http://www.abc.com/a.js</a><br><a href="http://www.abc.com/b.js">http://www.abc.com/b.js</a></td><td align="center">相同域名下的不同文件</td><td align="center">ok</td></tr><tr><td align="center"><a href="http://www.abc.com:9090/a.js">http://www.abc.com:9090/a.js</a><br><a href="http://www.abc.com:2020/a.js">http://www.abc.com:2020/a.js</a></td><td align="center">不同的端口</td><td align="center">no</td></tr><tr><td align="center"><a href="http://www.abc.com/a.js">http://www.abc.com/a.js</a><br><a href="http://www.abd.com/a.js">http://www.abd.com/a.js</a></td><td align="center">不同域名</td><td align="center">no</td></tr><tr><td align="center"><a href="http://www.abc.com/a.js">http://www.abc.com/a.js</a><br><a href="https://www.abc.com/a.js">https://www.abc.com/a.js</a></td><td align="center">不同协议</td><td align="center">no</td></tr><tr><td align="center"><a href="http://b.abc.com/a.js">http://b.abc.com/a.js</a><br><a href="https://www.abc.com/a.js">https://www.abc.com/a.js</a></td><td align="center">主域名不同</td><td align="center">no</td></tr></tbody></table><p>&emsp;&emsp;简而言之就是必须要协议域名端口完全相同才不会触发非同源策略，不然都是属于跨域的，那么针对这种情况，我们可以有以下几种解决的方法。</p><h3 id="1、jsonp"><a href="#1、jsonp" class="headerlink" title="1、jsonp"></a>1、jsonp</h3><p>因为浏览器中有三种标签天生就支持跨域<code>&lt;img&gt;&lt;script&gt;&lt;link&gt;</code>，<code>jsonp</code>就是利用<code>script</code>标签的性质，通过<code>script</code>传输<code>JSON</code>数据。因为此方法比较简单，而且可以兼容性强，所以简单解决跨域问题是可以的，但是这种方法有很大的问题，因为是script标签传输JSON，所以：</p><ul><li>只能支持get方法</li><li>不安全，可能会受到XSS的攻击</li></ul><p>&emsp;&emsp;我在自己的服务器上搭建了一个简单的接口，返回一串callback(‘测试数据’)的字符串，可以实现跨域请求数据。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonp</span>(<span class="hljs-params">&#123;</span></span><span class="hljs-params"><span class="hljs-function">    url,</span></span><span class="hljs-params"><span class="hljs-function">    callback</span></span><span class="hljs-params"><span class="hljs-function">    &#125;</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>)        <span class="hljs-built_in">window</span>[callback] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            resolve(data)            <span class="hljs-built_in">document</span>.body.removeChild(script)        &#125;        script.src = <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?callback=<span class="hljs-subst">$&#123;callback&#125;</span>`</span>        <span class="hljs-built_in">document</span>.body.appendChild(script)        &#125;)    &#125;jsonp(&#123;    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://xxx.xx.xx.xx:7777/api/test&#x27;</span>,    <span class="hljs-attr">callback</span>: <span class="hljs-string">&#x27;show&#x27;</span>    &#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(data)    &#125;)</code></pre><h3 id="2、document-domain-iframe"><a href="#2、document-domain-iframe" class="headerlink" title="2、document.domain + iframe"></a>2、document.domain + iframe</h3><p> 当仅仅只有子域不同时，我们只需要在js中强制设置<code>document.domain</code>为基础主域，就可以实现跨域<br> <pre><code class="hljs javascript"><span class="hljs-comment">//a.xxx.com/a.html</span>&lt;iframe id=<span class="hljs-string">&#x27;iframe&#x27;</span> src=<span class="hljs-string">&#x27;http://b.xxx.com/b.html&#x27;</span> style=<span class="hljs-string">&#x27;display:none;&#x27;</span>&gt;&lt;/iframe&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><span class="javascript"><span class="xml">    <span class="hljs-built_in">document</span>.domain = <span class="hljs-string">&#x27;xxx.com&#x27;</span>;</span></span><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> user = <span class="hljs-string">&#x27;admin&#x27;</span>;</span></span><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="hljs-comment">//b.xxx.com/b.html</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><span class="javascript"><span class="xml">    <span class="hljs-built_in">document</span>.domain = <span class="hljs-string">&#x27;xxx.com&#x27;</span>;</span></span><span class="javascript"><span class="xml">    <span class="hljs-comment">// 获取父窗口中变量</span></span></span><span class="javascript"><span class="xml">    alert(<span class="hljs-string">&#x27;get js data from parent ---&gt; &#x27;</span> + <span class="hljs-built_in">window</span>.parent.user);</span></span><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></p><p>其他的如<code>location.hash</code>,<code>window.name </code>都是类似的方法，但是个人觉得不好用，所以就略过吧。</p><h3 id="3、postMessage"><a href="#3、postMessage" class="headerlink" title="3、postMessage"></a>3、postMessage</h3><p>&emsp;&emsp;<code>window.postMessage()</code>方法提供了一种可控制的机制来安全地规避同源策略，安全地实现了Window对象之间的跨域通信。例如，在页面与其产生的弹出窗口之间，或在页面与嵌入其中的iframe之间。<br>&emsp;&emsp;大致上来说，一个窗口可以获取对另一个窗口的引用，例如：通过<code>targetWindow = window.opener</code>来获取另一个页面的对象，然后使用来<code>MessageEvent</code>在其上分派一个<code>targetWindow.postMessage()</code>，然后，接收窗口可以根据自身需要自由的处理此事件。传递给事件的参数<code>window.postMessage()</code>（即“消息”）通过<strong>事件对象</strong>暴露给接收窗口。</p><pre><code class="hljs javascript"><span class="hljs-comment">//9090</span> <span class="hljs-keyword">var</span> targetWindow = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;http://xxx.xxx.com:9090&#x27;</span>); targetWindow.posetMessage(<span class="hljs-string">&#x27;hello,i am 9090&#x27;</span>,<span class="hljs-string">&#x27;http://xxx.xxx.com:9091&#x27;</span>); targetWindow.addEventListener(<span class="hljs-string">&#x27;event&#x27;</span>,<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>&#123;     <span class="hljs-keyword">if</span>(e.origin!==<span class="hljs-string">&#x27;https://xxx.xxx.com:9090&#x27;</span>)     <span class="hljs-keyword">return</span>     <span class="hljs-built_in">console</span>.log(e.data) <span class="hljs-comment">// i am 9091</span> &#125;,<span class="hljs-literal">false</span>)<span class="hljs-comment">//9091</span><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (event.origin !== <span class="hljs-string">&quot;http://xxx.xxx.com:9090&quot;</span>)    <span class="hljs-keyword">return</span>;  <span class="hljs-built_in">console</span>.log(e.data) <span class="hljs-comment">// hello,i am 9090</span>  event.source.postMessage(<span class="hljs-string">&#x27;i am 9091&#x27;</span>,event.origin);&#125;, <span class="hljs-literal">false</span>);</code></pre><h3 id="4、CORS"><a href="#4、CORS" class="headerlink" title="4、CORS"></a>4、CORS</h3><p><code>CORS</code>需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><p>&emsp;&emsp;整个<code>CORS</code>通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现<code>CORS</code>通信的关键是<strong>服务器</strong>。只要服务器实现了<code>CORS</code>接口，就可以跨源通信。</p><h3 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h3><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。<br>&emsp;只要同时满足以下两大条件，就属于简单请求。</p><ol><li>请求方法是以下三种方法之一：<code>HEAD</code>、<code>GET</code>、<code>POST</code></li><li>HTTP的头信息不超出以下几种字段：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Last-Event-ID</code>、<code>Content-Type</code>（其中<code>Content-Type</code>只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>）<br>这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。**<em>凡是不同时满足上面两个条件，就属于非简单请求**</em>。<br>浏览器对这两种请求的处理，是不一样的。<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4>&emsp;&emsp;浏览器发送简单请求时，会自动在头上加上<code>Origin</code>字段。<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</li></ol><ul><li><p>如果服务器<code>Access-Control-Allow-Origin</code>规定的许可范围内没有这个值，会返回一个头信息中不包含<code>Access-Control-Allow-Origin</code>字段的响应，此时浏览器会检测到错误并抛出错误。此错误不能从状态码中发现。</p></li><li><p>如果在许可范围内，服务器返回的响应中会多处几个头字段</p><ul><li>1）Access-Control-Allow-Origin</li></ul><p>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p><ul><li>2）Access-Control-Allow-Credentials</li></ul><p>该字段可选。它的值是一个布尔值，表示是否允许发送<code>Cookie</code>。默认情况下，<code>Cookie</code>不包括在CORS请求之中。设为true，即表示服务器明确许可，<code>Cookie</code>可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送<code>Cookie</code>，删除该字段即可。</p><ul><li>3）Access-Control-Expose-Headers</li></ul><p>该字段可选。<code>CORS</code>请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。</p><p>想要通过<code>CORS</code>发送<code>Cookie</code>，想要同时在服务器设置<code>Access-Control-Allow-Credentials</code>字段为<code>true</code>，另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。</p><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-type">XMLHttpRequest</span>();xhr.withCredentials = <span class="hljs-literal">true</span>;</code></pre><p>同时如果要发送<code>Cookie</code>，<code>Access-Control-Allow-Origin</code>就不能设为<code>*</code>，必须指定明确的、与请求网页一致的域名。同时，<code>Cookie</code>依然遵循同源政策，只有用服务器域名设置的<code>Cookie</code>才会上传，<strong>其他域名的<code>Cookie</code>并不会上传</strong>，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的<code>Cookie</code>。</p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>&emsp;&emsp;浏览器发现这是一个非简单请求时，会自动发出一个<strong>预检</strong>请求，要求服务器确认可以这样请求。<strong>预检</strong>请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。<br>其中，”预检”请求的头信息包括两个特殊字段：<br>（1）Access-Control-Request-Method<br>&emsp;&emsp;该字段是必须的，用来列出浏览器的<code>CORS</code>请求会用到哪些HTTP方法，如<code>PUT</code>，<code>DELETE</code><br>（2）Access-Control-Request-Headers<br>&emsp;&emsp;该字段是一个逗号分隔的字符串，指定浏览器<code>CORS</code>请求会额外发送的头信息字段<br>服务器收到请求后，会先进行<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>的检查，确认是否是可以跨域的请求：</p></li><li><p>如果检查没问题，就会返回添加了相应头字段的响应</p></li><li><p>如果服务器否定了预检请求，会返回一个正常的<code>HTTP</code>回应，但是没有任何<code>CORS</code>相关的头信息字段。这时,浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获，在控制台报错。<br>其中正确返回的响应的头字段会加入一下几个字段：<br>（1）Access-Control-Allow-Methods<br>&emsp;&emsp;<strong>该字段必需</strong>，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。<br>（2）Access-Control-Allow-Headers<br>&emsp;&emsp;如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。<br>（3）Access-Control-Allow-Credentials<br>&emsp;&emsp;该字段与简单请求时的含义一样都是是否允许发送<code>Cookie</code>。<br>（4）Access-Control-Max-Age<br>&emsp;&emsp;该字段可选，用来指定本次预检请求的有效期，单位为秒。比如缓存时间设置为1728000秒（20天），那么在此期间，都不用发出另一条预检请求，此期间之前的预检请求会存活直到期。</p><h3 id="5、服务器中转"><a href="#5、服务器中转" class="headerlink" title="5、服务器中转"></a>5、服务器中转</h3><p>因为<strong>跨域是浏览器行为，不是服务器行为</strong>，所以实际上每次跨域请求都是到达服务器了的，只不过在回来的时候被浏览器限制了。所以我们可以通过服务器去实现访问，然后把数据从我们自己的同源中请求到。</p><h4 id="nginx代理"><a href="#nginx代理" class="headerlink" title="nginx代理"></a>nginx代理</h4><p>&emsp;&emsp;通过<code>nginx</code>代理我们要访问的地址，借助中转服务器去访问</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span> proxy服务器server &#123;    listen       <span class="hljs-number">80</span>;    server_name  www.my.com;    location /api &#123;        <span class="hljs-regexp">//</span>移除api        rewrite ^<span class="hljs-regexp">/api/</span>(.*)$ /&amp;<span class="hljs-number">1</span> <span class="hljs-keyword">break</span>;        proxy_pass   http:<span class="hljs-regexp">//</span>www.target.com;  <span class="hljs-comment">#反向代理</span>        proxy_cookie_domain www.domain2.com www.domain1.com; <span class="hljs-comment">#修改cookie里域名</span>    &#125;&#125;</code></pre><h4 id="6、nodejs中间件代理"><a href="#6、nodejs中间件代理" class="headerlink" title="6、nodejs中间件代理"></a>6、nodejs中间件代理</h4><p>&emsp;&emsp;<code>node</code>做一层中间代理服务器，首先<code>node</code>接收接受客户端请求,然后将请求转发给目标服务器，<code>node</code>拿到目标服务器的响应数据，之后<code>node</code>将响应结果发给客户端，至此完成跨域请求。</p><h3 id="7、WebSocker协议"><a href="#7、WebSocker协议" class="headerlink" title="7、WebSocker协议"></a>7、WebSocker协议</h3><p><code>WebSocker</code>是<code>HTML5</code>的一种持久化协议，可以在服务端和客户端建立起双向的通信通道，实现持久的数据通信，一般都是用来做通信聊天的，既然可以进行数据交互，我们拿来跨域也是可以的，不过就是不方便而已啦</p></li></ul><p>&emsp;&emsp;综上，就这么几种解决跨域的方法，总结一下他们的差异：</p><ol><li>jsonp<br>需要目标服务器配合一个<code>callback</code>函数　</li><li>window.name+iframe<br>需要目标服务器响应<code>window.name</code></li><li>window.location.hash+iframe<br>同样需要目标服务器作处理</li><li>html5的postMessage+ifrme<br>这个也是需要目标服务器或者说是目标页面写一个postMessage，主要侧重于前端通讯</li><li>CORS<br>需要服务器设置header :Access-Control-Allow-Origin</li><li>服务器中转<br><code>nginx</code>反向代理或<code>node</code>代理中间层 这个方法一般很少有人提及，但是他可以不用目标服务器配合，不过需要你搭建一个中转<code>nginx</code>服务器，用于转发请求</li><li>WebSocker 双方都需要实现WebSocker，也不太方便<br>所以我还是比较喜欢CORS和中转的方法的。</li></ol>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RESTFULL</title>
    <link href="/2020/11/09/RESTFULL/"/>
    <url>/2020/11/09/RESTFULL/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是RESTFUL架构"><a href="#什么是RESTFUL架构" class="headerlink" title="什么是RESTFUL架构"></a>什么是RESTFUL架构</h2><p>REST代表<code>Respersontational State Transfer</code>，通常理解为表现层状态转移，他是围绕资源展开的，每个组件都是资源，都是可以通过唯一的URL访问到的，REST体系将所有的内容都视为资源，这些资源可以是文本、HTML页面、图像、视频或者业务数据。<code>REST Server</code>只提供对资源的访问，<code>REST Client</code>访问和修改这些资源，REST可以使用各种的形式来表现这些资源，主要是使用JSON，也可以是Text或者XML。</p><h2 id="REST的约束条件"><a href="#REST的约束条件" class="headerlink" title="REST的约束条件"></a>REST的约束条件</h2><h3 id="客户端-服务器"><a href="#客户端-服务器" class="headerlink" title="客户端-服务器"></a>客户端-服务器</h3><p>&emsp;&emsp;通过将用户接口和数据存储的问题分开，提高了接口的可移植性。</p><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>&emsp;&emsp;<code>RESTful Web</code>服务不应该在服务器保存客户端的状态，这种限制被称为无状态，客户端负责把上下文传递给服务器，然后服务器去存储他的上下午以供服务器进行进一步的处理和请求，比如我们需要获得某个用户的信息，我们应该是通过客户端传递userId给服务器，服务器处理好了返回结果给我们，对服务器而言他不知道每次的状态是什么。这样可以使得Web服务不需要维护客户端以前的交互（因为他不知道这个客户端之前干嘛了）</p><h3 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h3><p>&emsp;&emsp;指客户端应该将服务器的响应存储在客户端本身中，如此客户端无需一次又一次的向服务器请求相同的资源。同事服务器响应应该有如何进行缓存的信息，以方便客户端在一段时间内进行缓存响应。如以下服务器应该具备的响应头以便客户端配置缓存</p><table><thead><tr><th>Sr.No.</th><th>Header &amp; Description</th></tr></thead><tbody><tr><td>1</td><td><strong>Date</strong><br/>资源创建的日期和时间</td></tr><tr><td>2</td><td><strong>Last Modified</strong><br/>资源上次修改的日期和时间</td></tr><tr><td>3</td><td><strong>Cache-Control</strong><br>用于控制缓存的主标记头</td></tr><tr><td>4</td><td><strong>Expires</strong><br/>缓存的到期日期和时间</td></tr><tr><td>5</td><td><strong>Age</strong><br/>从服务器获得资源后的持续时间</td></tr></tbody></table><table><thead><tr><th>Sr.No.</th><th>Directive &amp; Description</th></tr></thead><tbody><tr><td>1</td><td><strong>Public</strong><br/>公共的可缓存资源</td></tr><tr><td>2</td><td><strong>Private</strong><br/>表示资源只可以被客户端和服务器缓存，中介不能缓存的资源</td></tr><tr><td>3</td><td><strong>no-cache/no-store</strong><br/>指资源不可以缓存</td></tr><tr><td>4</td><td><strong>max-age</strong><br/>表示缓存的最长有效期。超过事件后就需要客户端再次请求</td></tr><tr><td>5</td><td><strong>must-revalidate</strong><br/>在超过有效期后，服务器必须重新验证资源</td></tr></tbody></table><h2 id="RESTful传递消息的方式"><a href="#RESTful传递消息的方式" class="headerlink" title="RESTful传递消息的方式"></a>RESTful传递消息的方式</h2><p>&emsp;&emsp;因为REST的无状态限制，HTTP无状态协议和他很契合。客户端通过HTTP请求发送消息，服务器以HTTP形式响应。常见的有四种动作：GET,POST,PUT,DELETE其中要考虑的是：</p><ul><li>GET操作是只读的并且是安全的。</li><li>PUT和DELETE操作是幂等的，这意味着无论调用多少次这些操作，其结果都将始终相同。</li><li>PUT和POST操作几乎相同，不同之处仅在于PUT操作是幂等的，而POST操作可能导致不同的结果<h2 id="关于RESTful架构的寻址要求"><a href="#关于RESTful架构的寻址要求" class="headerlink" title="关于RESTful架构的寻址要求"></a>关于RESTful架构的寻址要求</h2>寻址是指定位服务器上的一个或者多个资源。因为REST架构的每个资源都通过URL来标识，所以关于寻址的URL我们需要考虑以下几点：</li><li>使用复数名词定义<br>例如，我们要访问用户资源应该使用users而不是user</li><li>避免使用空格而使用_或者-代替</li><li>使用小写字母</li><li>保持向后兼容<br>&emsp;&emsp;因为一些Web服务一旦上线，可能需要保证始终可用，一旦我们的资源移动了位置，我们需要通过HTTP的3xx状态告知客户端将就URL重定向新的URL</li><li>使用HTTP动词，URL不包含动词<br>我们使用POST、GET等动词来表示请求方式，之后的URL里的资源应该使用名词来形容，比如我们需要获得User信息，<code>../UserManagement/rest/UserService/getUser/1</code>，其中使用<code>getUser</code>是不太好的，因为使用<code>UserManagement/rest/UserService/users/1</code>，来形容我们的资源。<br>参考自：<a href="https://www.tutorialspoint.com/restful/restful_addressing.htm">restful</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>restful</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SOLID</title>
    <link href="/2020/11/09/SOLID/"/>
    <url>/2020/11/09/SOLID/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式之SOLID原则"><a href="#设计模式之SOLID原则" class="headerlink" title="设计模式之SOLID原则"></a>设计模式之SOLID原则</h2><p>&emsp;&emsp;SOLID原则是为了让程序员更加轻松的开发出易于维护和拓展的软件，避免代码的冗杂，让我们可以很轻松的重构代码。<code>SOLID</code>原则的五大原则分别为：</p><h2 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则(Single Responsibility Principle, SRP)"></a>单一职责原则(Single Responsibility Principle, SRP)</h2><p>&emsp;&emsp;<code>SRP</code>简单来说就是解耦，类似于工厂里的分工方式，每个工人只需要做好一件事就可以了（当然现在这个社会其实每个人不能只会一样，不利于个人发展的），对于我们软件中的类来说也是这样的，每个类只需要负责某一方面的职责即可，如此可以方便我们对这些类进行复用，组合。实现高内聚低耦合的设计原则。不过因为将功能进行了较为细致的拆分，所以在需要进行大面积修改时可能会有不小的工作量。</p><h2 id="开闭原则-Open-Closed-Principle-OCP"><a href="#开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="开闭原则(Open-Closed Principle, OCP)"></a>开闭原则(Open-Closed Principle, OCP)</h2><p>对象应该可以进行扩展，但是不能进行修改。软件的需求发生改变后，我们的系统应该保持设计框架的稳定，不能因为一个需求的修改出现大量的更改，当我们的软件符合开闭原则之后，我们可以对某个需要修改的组件对象进行扩展，而不用修改现有的代码，降低了维护成本。</p><h2 id="里氏代换原则-Liskov-Substitution-Principle"><a href="#里氏代换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏代换原则(Liskov Substitution Principle)"></a>里氏代换原则(Liskov Substitution Principle)</h2><p>&emsp;&emsp;里氏替换原则是Liskov提出的关于继承的一些原则。Robert C. Martin简化的说过里氏替换原则就是**<em>Subtypes must be substitutable for their base types**</em>，就是说子类必须能够替换他们的基类。因此我们需要注意以下几点：</p><ul><li><p>子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。</p></li><li><p>子类中可以增加自己特有的方法。</p></li><li><p>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比- 父类方法的输入参数更宽松。(即只能重载不能重写)</p></li><li><p>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">father</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;    <span class="hljs-built_in">this</span>.x = x;    <span class="hljs-built_in">this</span>.y = y;  &#125;  <span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x+<span class="hljs-built_in">this</span>.y;  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">father</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x,y</span>)</span>&#123;    <span class="hljs-built_in">super</span>(x,y);  &#125;  <span class="hljs-function"><span class="hljs-title">minus</span>(<span class="hljs-params">x,y</span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x-<span class="hljs-built_in">this</span>.y;  &#125;&#125;<span class="hljs-keyword">let</span> fat = <span class="hljs-keyword">new</span> father(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-keyword">let</span> so = <span class="hljs-keyword">new</span> son(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(fat.sum(),so.sum(),so.minus());<span class="hljs-comment">// 3  3  -1</span><span class="hljs-comment">//父类被子类替换后结果也是一样的</span></code></pre><h2 id="依赖倒置原则-Dependence-Inversion-Principle-DIP"><a href="#依赖倒置原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="依赖倒置原则(Dependence Inversion Principle,DIP)"></a>依赖倒置原则(Dependence Inversion Principle,DIP)</h2><p>&emsp;&emsp;实体必须依赖抽象而不依赖具体。高级模块一定不能依赖于低级模块，而应该依赖于抽象。简单来说就是将我们平时的依赖反转，不再是高级模块去依赖低级模块，而是低级模块反向依赖一个抽象类，然后高级模块也依赖于这个抽象类。从而剥离模块之间的关联，达到了解耦的目的。关于这块还有一个IOC控制反转，利用容器将控制权反转，将对象的获得等控制权交给容器，如此来降低耦合。</p><h2 id="接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="接口隔离原则(Interface Segregation Principle, ISP)"></a>接口隔离原则(Interface Segregation Principle, ISP)</h2><p>&emsp;&emsp;要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。<br>参考于：<a href="https://www.jianshu.com/p/3268264ae581">更详细的六大设计原则</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>solid</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise三兄弟all,race,allsettled</title>
    <link href="/2020/10/03/promise%E4%B8%89%E5%85%84%E5%BC%9F/"/>
    <url>/2020/10/03/promise%E4%B8%89%E5%85%84%E5%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><p>Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 promise 的结果。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1=<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>);<span class="hljs-keyword">const</span> promise2=<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>);<span class="hljs-keyword">const</span> promise3=<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>);<span class="hljs-keyword">const</span> promise4=<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">4</span>);<span class="hljs-keyword">const</span> promise = [promise1,promise2,promise3,promise4]<span class="hljs-built_in">Promise</span>.all(promise).then(<span class="hljs-function"><span class="hljs-params">val</span>=&gt;</span>&#123;    val.forEach(<span class="hljs-function"><span class="hljs-params">r</span>=&gt;</span><span class="hljs-built_in">console</span>.log(r))&#125;).catch(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(res)&#125;)<span class="hljs-comment">//3</span></code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>all的特性是只要有一个<code>rejected</code>就返回该失败结果，其他的都当作没发生。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 串行执行</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myAll</span>(<span class="hljs-params">promises</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> (r,j)=&gt;&#123;    <span class="hljs-keyword">let</span> data = [],Err,isError=<span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> promise <span class="hljs-keyword">of</span> promises)&#123;        <span class="hljs-keyword">if</span>(isError) <span class="hljs-keyword">break</span>;        promise = promise <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? promise : <span class="hljs-built_in">Promise</span>.resolve(promise);        <span class="hljs-keyword">await</span> promise.then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;            data.push(res);        &#125;,<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;          isError=<span class="hljs-literal">true</span>;            j(error)        &#125;)        &#125;        r(data);  &#125;)&#125;<span class="hljs-comment">//并发执行</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myAllConcurrence</span>(<span class="hljs-params">promises</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">r,j</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> data=[],isError=<span class="hljs-literal">false</span>,num=promises.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> promise <span class="hljs-keyword">of</span> promises)&#123;      <span class="hljs-keyword">if</span>(isError) <span class="hljs-keyword">break</span>;      promise = promise <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? promise : <span class="hljs-built_in">Promise</span>.resolve(promise);      promise.then(<span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;        data.push(result);        num ? r(data) : num--;        &#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>&#123;        isError=<span class="hljs-literal">true</span>;        j(e);      &#125;)    &#125;  &#125;)&#125;</code></pre><h2 id="race"><a href="#race" class="headerlink" title="race"></a>race</h2><p>Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1=<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>);<span class="hljs-keyword">const</span> promise2=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(reject, <span class="hljs-number">500</span>, <span class="hljs-string">&#x27;500&#x27;</span>);&#125;);<span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;1000&#x27;</span>);&#125;);<span class="hljs-keyword">const</span> promise4=<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">4</span>);<span class="hljs-keyword">const</span> promise = [promise3,promise2,promise1,promise4];<span class="hljs-built_in">Promise</span>.race(promise).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(value);&#125;);<span class="hljs-comment">// 1 1最快得到结果，所以只会输出1</span></code></pre><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myRace</span>(<span class="hljs-params">promises</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">r,j</span>)=&gt;</span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> promise <span class="hljs-keyword">of</span> promises)&#123;                promise = promise <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? promise : <span class="hljs-built_in">Promise</span>.resolve(promise);            promise.then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;            r(res)        &#125;,<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;            j(error)        &#125;)        &#125;  &#125;)&#125;</code></pre><h2 id="allsettled"><a href="#allsettled" class="headerlink" title="allsettled"></a>allsettled</h2><p>Promise.allSettled()方法返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。当有多个彼此不依赖的异步任务成功完成时，或者我们要得到每个promise的结果的时候，可以使用。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1=<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>);<span class="hljs-keyword">const</span> promise2=<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>);<span class="hljs-keyword">const</span> promise3=<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>);<span class="hljs-keyword">const</span> promise4=<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">4</span>);<span class="hljs-keyword">const</span> promise = [promise1,promise2,promise3,promise4]<span class="hljs-built_in">Promise</span>.allSettled(promise).then(<span class="hljs-function"><span class="hljs-params">val</span>=&gt;</span>&#123;    val.forEach(<span class="hljs-function"><span class="hljs-params">re</span>=&gt;</span><span class="hljs-built_in">console</span>.log(re))&#125;)<span class="hljs-comment">//&gt; Object &#123; status: &quot;fulfilled&quot;, value: 1 &#125;</span><span class="hljs-comment">//&gt; Object &#123; status: &quot;fulfilled&quot;, value: 2 &#125;</span><span class="hljs-comment">//&gt; Object &#123; status: &quot;rejected&quot;, reason: 3 &#125;</span><span class="hljs-comment">//&gt; Object &#123; status: &quot;fulfilled&quot;, value: 4 &#125;</span></code></pre><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>根据其特性，不难实现allSettled，我们只需要得到所有的promise结果存到数组返回即可。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myAllSettled</span>(<span class="hljs-params">promises</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> resolve=&gt;&#123;    <span class="hljs-keyword">let</span> data=[];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> promise <span class="hljs-keyword">of</span> promises)&#123;      promise = promise <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? promise : <span class="hljs-built_in">Promise</span>.resolve(promise)        <span class="hljs-keyword">await</span> promise.then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;        data.push(&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>, <span class="hljs-attr">value</span>: res &#125;);      &#125;,<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;        data.push(&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>, <span class="hljs-attr">reason</span>: error &#125;);      &#125;)    &#125;    resolve(data);  &#125;)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>手写</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写汇总</title>
    <link href="/2020/10/03/%E6%89%8B%E5%86%99/"/>
    <url>/2020/10/03/%E6%89%8B%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="一些手写的内容汇总"><a href="#一些手写的内容汇总" class="headerlink" title="一些手写的内容汇总"></a>一些手写的内容汇总</h1><h2 id="1、通过XMLHttpRequest实现网络请求"><a href="#1、通过XMLHttpRequest实现网络请求" class="headerlink" title="1、通过XMLHttpRequest实现网络请求"></a>1、通过XMLHttpRequest实现网络请求</h2><pre><code class="hljs qml"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-built_in">url</span>,<span class="hljs-literal">true</span>)<span class="hljs-comment">//异步，false同步</span>xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">if</span>(xhr.readyState==<span class="hljs-number">4</span>&amp;&amp;xhr.state==<span class="hljs-number">200</span>)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;成功&#x27;</span>)  <span class="hljs-keyword">else</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;失败&#x27;</span>)&#125;xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;连接失败&#x27;</span>,e)&#125;xhr.send();</code></pre><h2 id="2、手写call-apply-bind"><a href="#2、手写call-apply-bind" class="headerlink" title="2、手写call(),apply(),bind()"></a>2、手写call(),apply(),bind()</h2><p>之前探讨了这三种函数的区别，正好理解的还算可以，所以试一试写出三种函数的手写代码。</p><h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.call = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg</span>)</span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;不能被call&#x27;</span>);    &#125;  <span class="hljs-comment">//如果传入的是null或者undefined 或者空则绑定为全局</span>    <span class="hljs-keyword">let</span> thisArg = thisArg || <span class="hljs-built_in">window</span>;  <span class="hljs-comment">//在传入的对象上创建方法并赋给它</span>  thisArg.fn = <span class="hljs-built_in">this</span>;    <span class="hljs-keyword">let</span> args = [];  <span class="hljs-comment">//把参数拿出来，从第二个拿，第一个是指定的this</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-built_in">arguments</span>.length; i++)&#123;    args.push(<span class="hljs-string">`arguments[<span class="hljs-subst">$&#123;i&#125;</span>]`</span>)  &#125;  <span class="hljs-comment">//把参数传入对象的方法执行，得到结果</span>  <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">`context.fn(<span class="hljs-subst">$&#123;args&#125;</span>)`</span>);  <span class="hljs-comment">//删除方法</span>  <span class="hljs-keyword">delete</span> thisArg.fn;  <span class="hljs-comment">//返回结果</span>  <span class="hljs-keyword">return</span> result;&#125;</code></pre><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.apply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg,arr</span>)</span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;不能被apply&#x27;</span>);    &#125;  <span class="hljs-comment">//如果传入的是null或者undefined 或者空则绑定为全局</span>    <span class="hljs-keyword">let</span> thisArg = <span class="hljs-built_in">Object</span>(thisArg) || <span class="hljs-built_in">window</span>;  <span class="hljs-comment">//在传入的对象上创建方法并赋给它</span>  thisArg.fn = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">let</span> result;  <span class="hljs-comment">//如果arr没有，就直接执行</span>  <span class="hljs-keyword">if</span>(!arr)&#123;    result = thisArg.fn();  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-comment">//如果有参数就一一取出来给方法执行</span>    <span class="hljs-keyword">let</span> args = [];    <span class="hljs-comment">//把参数拿出来，从第二个拿，第一个是指定的this</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i &lt; arr.length; i++)&#123;      args.push(<span class="hljs-string">`arguments[<span class="hljs-subst">$&#123;i&#125;</span>]`</span>)    &#125;    <span class="hljs-comment">//把参数传入对象的方法执行，得到结果</span>    <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">`context.fn(<span class="hljs-subst">$&#123;args&#125;</span>)`</span>);   &#125;  <span class="hljs-comment">//删除方法</span>  <span class="hljs-keyword">delete</span> thisArg.fn;  <span class="hljs-comment">//返回结果</span>  <span class="hljs-keyword">return</span> result;&#125;</code></pre><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p>以上两种都好写，但是bind()因为要返回一个新的函数，然后还可以被new出来，new之后this指向新创建的new实例。</p><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherThis</span>) </span>&#123;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;不能被bind&#x27;</span>);   &#125;  <span class="hljs-comment">//把第一个参数后面的参数拿出来</span>   <span class="hljs-keyword">var</span> baseArgs= <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>),       baseArgsLength = baseArgs.length,       fToBind = <span class="hljs-built_in">this</span>,       fNOP    = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;,       fBound  = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;         baseArgs.length = baseArgsLength; <span class="hljs-comment">// reset to default base arguments</span>         baseArgs.push.apply(baseArgs, <span class="hljs-built_in">arguments</span>);         <span class="hljs-keyword">return</span> fToBind.apply(                fNOP.prototype.isPrototypeOf(<span class="hljs-built_in">this</span>) ? <span class="hljs-built_in">this</span> : otherThis, baseArgs         );       &#125;;   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.prototype) &#123;     <span class="hljs-comment">// Function.prototype doesn&#x27;t have a prototype property</span>     fNOP.prototype = <span class="hljs-built_in">this</span>.prototype;    &#125;   fBound.prototype = <span class="hljs-keyword">new</span> fNOP();   <span class="hljs-keyword">return</span> fBound; &#125;;</code></pre><p>以上代码是mdn上的代码，但是和原本的bind函数还是有很大差别。以下是一个较为完整的方案。</p><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">that</span>) </span>&#123;    <span class="hljs-keyword">var</span> target = <span class="hljs-built_in">this</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;function&#x27;</span> || toStr.call(target) !== funcType) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(ERROR_MESSAGE + target);    &#125;    <span class="hljs-keyword">var</span> args = slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">var</span> bound;    <span class="hljs-keyword">var</span> binder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> bound) &#123;            <span class="hljs-keyword">var</span> result = target.apply(                <span class="hljs-built_in">this</span>,                args.concat(slice.call(<span class="hljs-built_in">arguments</span>))            );            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>(result) === result) &#123;                <span class="hljs-keyword">return</span> result;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> target.apply(                that,                args.concat(slice.call(<span class="hljs-built_in">arguments</span>))            );        &#125;    &#125;;    <span class="hljs-keyword">var</span> boundLength = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, target.length - args.length);    <span class="hljs-keyword">var</span> boundArgs = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; boundLength; i++) &#123;        boundArgs.push(<span class="hljs-string">&#x27;$&#x27;</span> + i);    &#125;    bound = <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;binder&#x27;</span>, <span class="hljs-string">&#x27;return function (&#x27;</span> + boundArgs.join(<span class="hljs-string">&#x27;,&#x27;</span>) + <span class="hljs-string">&#x27;)&#123; return binder.apply(this,arguments); &#125;&#x27;</span>)(binder);    <span class="hljs-keyword">if</span> (target.prototype) &#123;        <span class="hljs-keyword">var</span> Empty = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Empty</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;        Empty.prototype = target.prototype;        bound.prototype = <span class="hljs-keyword">new</span> Empty();        Empty.prototype = <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">return</span> bound;&#125;;</code></pre><h2 id="3、手写数组深拷贝"><a href="#3、手写数组深拷贝" class="headerlink" title="3、手写数组深拷贝"></a>3、手写数组深拷贝</h2><p>深拷贝，主要是要对深层次的内容进行拷贝，拷贝到新的地址里。</p><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> deep<span class="hljs-constructor">Clone(<span class="hljs-params">obj</span>)</span>&#123;    <span class="hljs-keyword">if</span>(typeof obj!=&#x27;<span class="hljs-keyword">object</span>&#x27;<span class="hljs-operator"> || </span>obj ==null)&#123;    return obj  &#125;  <span class="hljs-keyword">let</span> result;  <span class="hljs-keyword">if</span>(obj instanceof Array)&#123;    result = <span class="hljs-literal">[]</span>  &#125;<span class="hljs-keyword">else</span>&#123;    result = &#123;&#125;  &#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj)&#123;    <span class="hljs-keyword">if</span>(obj.has<span class="hljs-constructor">OwnProperty(<span class="hljs-params">key</span>)</span>)&#123;        result<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>=deep<span class="hljs-constructor">Clone(<span class="hljs-params">obj</span>[<span class="hljs-params">key</span>])</span>    &#125;  &#125;  return result;&#125;<span class="hljs-keyword">let</span> test = &#123;  aa:<span class="hljs-number">12</span>,  bb:&#x27;<span class="hljs-built_in">string</span>&#x27;,  cc:<span class="hljs-literal">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]</span>,  dd:&#123;    ab:<span class="hljs-number">123</span>,    ac:&#x27;<span class="hljs-built_in">array</span>&#x27;,    bc:<span class="hljs-literal">[&#x27;<span class="hljs-number">2</span>&#x27;,&#x27;<span class="hljs-number">3</span>&#x27;]</span>  &#125;&#125;test.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__proto__</span>.</span></span>gg=<span class="hljs-number">123</span>;deep<span class="hljs-constructor">Clone(<span class="hljs-params">test</span>)</span>==test       <span class="hljs-comment">//false</span><span class="hljs-keyword">let</span> tt = test;tt==test;                                   <span class="hljs-comment">//true</span></code></pre><h2 id="3、柯里化函数的实现"><a href="#3、柯里化函数的实现" class="headerlink" title="3、柯里化函数的实现"></a>3、柯里化函数的实现</h2><p>柯里化就是将多参数转换成单一参数的函数，要实现参数的分解，我们主要使用bind()来分解参数。</p><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">currying</span><span class="hljs-params">(fn,length)</span></span>&#123;length=length||fn.length;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span></span>&#123;    <span class="hljs-keyword">return</span> args.length &gt;= length ?       fn.apply(<span class="hljs-keyword">this</span>,args):    currying(fn.bind(<span class="hljs-keyword">this</span>,...args),length-args.length);  &#125;&#125;</code></pre><p><img src="https://proxy.qiupo.workers.dev/?https://raw.githubusercontent.com/qiupo/myImages/master/img/image.png" alt="代码实例"></p><h2 id="4、手写EventEmitter"><a href="#4、手写EventEmitter" class="headerlink" title="4、手写EventEmitter"></a>4、手写EventEmitter</h2><p>遇到这么个题目，嗯，题目，某人让我写一下，就写一下吧，照着文档算是能够实现一些功能了，但是有挺多要求没有实现的，但起码还是能达到一定要求的。<br>events（事件触发器）是nodejs中的提供事件触发的模块，events提供了类EventEmitter，EventEmitter 的核心就是事件触发与事件监听器功能的封装。提供了很多方法来进行监听器的绑定移除，这里我就只写其中几个简单的（主要是好实现，而且懒得做多了）。</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventEmitterOfme</span> </span>&#123;    <span class="hljs-keyword">constructor</span>() &#123;        <span class="hljs-keyword">this</span>.MaxListeners = <span class="hljs-number">10</span>;        <span class="hljs-keyword">this</span>.currentListeners = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.events = [];    &#125;    <span class="hljs-comment">//为指定事件添加一个监听器到监听器数组的尾部。</span>    addListener(event, listener) &#123;        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.events[event]) &#123;            console.log(<span class="hljs-string">&#x27;没有此监听器&#x27;</span>)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.events[event].push(listener);        &#125;    &#125;    <span class="hljs-comment">//为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。</span>    on(event, listener) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentListeners + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">this</span>.MaxListeners) &#123;            console.log(<span class="hljs-string">&#x27;超过监听器上限&#x27;</span>)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.events[event]) &#123;                <span class="hljs-keyword">this</span>.currentListeners++;                <span class="hljs-keyword">this</span>.events[event] = [listener];            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">this</span>.events[event].push(listener);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</span>    once(event, listener) &#123;        let fn = (arg) =&gt; &#123;            listener(arg);            <span class="hljs-keyword">this</span>.removeListener(event, fn);        &#125;        <span class="hljs-keyword">this</span>.on(event, fn);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。</span>    <span class="hljs-comment">//它接受两个参数，第一个是事件名称，第二个是回调函数名称。</span>    removeListener(event, listener) &#123;        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.events[event]) &#123;            console.log(`不存在$&#123;event&#125;监听器`)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.events[event].splice(<span class="hljs-keyword">this</span>.events[event].lastIndexOf(listener),<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</span>    removeAllListeners(events) &#123;        <span class="hljs-keyword">if</span> (events === undefined) &#123;            <span class="hljs-keyword">this</span>.events = [];            <span class="hljs-keyword">this</span>.currentListeners = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span>(let key of events) &#123;                delete <span class="hljs-keyword">this</span>.events[key];                <span class="hljs-keyword">this</span>.currentListeners--;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</span>    setMaxListeners(n) &#123;        <span class="hljs-keyword">this</span>.MaxListeners = n;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//返回指定事件的监听器数组。</span>    listeners(event) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.events[event]    &#125;    allListeners() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.events;    &#125;    <span class="hljs-comment">//按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</span>    emit(event, ...args) &#123;        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.events[event])            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.events[event].forEach((<span class="hljs-function"><span class="hljs-keyword">fun</span>, index) =&gt; <span class="hljs-keyword">fun</span>.<span class="hljs-title">call</span><span class="hljs-params">(this, args[index])</span></span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    &#125;&#125;</code></pre><h2 id="5、实现防抖函数"><a href="#5、实现防抖函数" class="headerlink" title="5、实现防抖函数"></a>5、实现防抖函数</h2><p>防抖的非立即执行版本就是在触发一次后的固定时间内，一直不会执行操作，如果在固定时间内触发了，则重新计时，如果一直没触发，则等到固定时间到了执行.</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thro</span>(<span class="hljs-params">fn,wait</span>)</span>&#123;    <span class="hljs-keyword">let</span> timer;  <span class="hljs-keyword">let</span> _that = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">let</span> agrs = <span class="hljs-built_in">arguments</span>;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">clearTimeout</span>(timer);        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;        fn.apply(_that,agrs);      &#125;,wait)  &#125;&#125;</code></pre><p>防抖的立即执行版本</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thro</span>(<span class="hljs-params">fn,wait,rightNow</span>)</span>&#123;    <span class="hljs-keyword">let</span> timer;  <span class="hljs-keyword">let</span> _that = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">let</span> agrs = <span class="hljs-built_in">arguments</span>;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">//进去先把计时器清除</span>    <span class="hljs-keyword">if</span>(timer) <span class="hljs-built_in">clearTimeout</span>(timer);    <span class="hljs-comment">//在这里判断是不是第一次运行，是就立刻执行，不是就只需要执行计时器就行</span>    <span class="hljs-keyword">const</span> im = !timer;    <span class="hljs-keyword">if</span>(rightNow)&#123;        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;        timer = <span class="hljs-literal">null</span>;      &#125;,wait);      <span class="hljs-keyword">if</span>(im) fn.apply(_that,agrs);    &#125;<span class="hljs-keyword">else</span>&#123;        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;        fn.apply(_that,agrs);      &#125;,wait)    &#125;  &#125;&#125;</code></pre><h2 id="6、节流函数"><a href="#6、节流函数" class="headerlink" title="6、节流函数"></a>6、节流函数</h2><p>节流函数就是在规定时间内只执行一次操作，触发多少次都只会执行一次。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thro</span>(<span class="hljs-params">fn,wait</span>)</span>&#123;<span class="hljs-keyword">let</span> timer;  <span class="hljs-keyword">let</span> _that = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">let</span> agrs = <span class="hljs-built_in">arguments</span>;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">if</span>(!timer)&#123;    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;      fn.apply(_that,agrs);        timer = <span class="hljs-literal">null</span>;      &#125;,wait)    &#125;  &#125;&#125;</code></pre><h2 id="7、手写flat-扁平化"><a href="#7、手写flat-扁平化" class="headerlink" title="7、手写flat()扁平化"></a>7、手写flat()扁平化</h2><p>一般是对数组实现扁平化，这里我们可以用到apply和concat的组合，因为apply会把数组参数拆解，所以正好符合我们拍扁数组的需求</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat</span>(<span class="hljs-params">arrs</span>)</span>&#123;  <span class="hljs-keyword">const</span> isDeep = arrs.some(<span class="hljs-function"><span class="hljs-params">arr</span>=&gt;</span>arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)  <span class="hljs-keyword">if</span>(!isDeep)&#123;    <span class="hljs-keyword">return</span> arrs  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">return</span> flat(<span class="hljs-built_in">Array</span>.prototype.concat.apply([],arrs))  &#125;&#125;flat([<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]) <span class="hljs-comment">//[1, 2, 2, 3, 3, 4, 5]</span></code></pre><h2 id="8、instanceof的实现"><a href="#8、instanceof的实现" class="headerlink" title="8、instanceof的实现"></a>8、instanceof的实现</h2><p>instanceof是通过判断其原型链上的属性是否在目标对象的原型链上也有，所以只需要对比prototype就行了。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">obj,resouceObj</span>)</span>&#123;  <span class="hljs-keyword">let</span> objProto = obj.__proto__;  <span class="hljs-keyword">let</span> resouceProto = resouceObj.prototype  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-keyword">if</span>(objProto === <span class="hljs-literal">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span>(objProto === resouceProto)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    objProto = objProto.__proto__  &#125;&#125;</code></pre><h2 id="9、手写继承"><a href="#9、手写继承" class="headerlink" title="9、手写继承"></a>9、手写继承</h2><p>JavaScript的继承虽然有class可以用extends来继承，但是如果需要我们使用原型链进行继承，我们就需要自己来实现了。<br>需要实现继承，需要我们把父类的原型链和静态属性继承到子类中，所以代码如下：</p><pre><code class="hljs reasonml"><span class="hljs-comment">//父类</span><span class="hljs-keyword">function</span> <span class="hljs-constructor">Parents(<span class="hljs-params">name</span>)</span>&#123;    this.name = name;&#125;<span class="hljs-comment">//父类原型链上的方法</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parents</span>.</span></span>prototype.getName = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span>&#123;    console.log(this.name)&#125;<span class="hljs-comment">//父类的静态方法</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parents</span>.</span></span>family = &#x27;Bob&#x27;;<span class="hljs-keyword">function</span> child(age)&#123;  <span class="hljs-comment">//继承父类的属性</span>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parents</span>.</span></span>call(this);&#125;<span class="hljs-comment">//把父类的原型链拷贝一个进来，同时把构造函数修正为自己的构造函数，并且不能被修改</span>child.prototype = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parents</span>.</span></span>prototype,&#123;    constructor:&#123;    value:<span class="hljs-keyword">new</span> child<span class="hljs-literal">()</span>,    writeable:<span class="hljs-literal">false</span>  &#125;&#125;);<span class="hljs-comment">//获取父类的静态属性</span><span class="hljs-keyword">let</span> keys = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>entries(Parents);<span class="hljs-comment">//把静态属性放进子类</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i&lt;keys.length;i++)&#123;    <span class="hljs-keyword">let</span> key = keys<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;  <span class="hljs-keyword">let</span> value = keys<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-number">1</span>]</span>;  child<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = value;&#125;<span class="hljs-keyword">new</span> child<span class="hljs-literal">()</span>;</code></pre><h2 id="10、手写new方法"><a href="#10、手写new方法" class="headerlink" title="10、手写new方法"></a>10、手写new方法</h2><p>new操作符做了哪些事情？</p><ul><li><p>创建一个新的对象</p></li><li><p>新对象会被执行[[Prototype]]连接，关联到构造函数的.prototype对象上</p></li><li><p>新对象会绑定到函数调用的this</p></li><li><p>如果函数没有返回其他对象，那么new表达式中的函数会调用自动返回这个新对象</p><pre><code class="hljs kotlin">function makeNew(<span class="hljs-function"><span class="hljs-keyword">fun</span>)&#123;</span>    <span class="hljs-keyword">if</span>(typeof <span class="hljs-function"><span class="hljs-keyword">fun</span> !== &quot;Object&quot;)&#123;</span>    <span class="hljs-keyword">throw</span> TypeError();  &#125;  let obj = Object.create(<span class="hljs-literal">null</span>);  <span class="hljs-comment">//设置对象的原型（即内部 [[Prototype]] 属性）。</span>  Object.setPrototypeof(obj,<span class="hljs-keyword">fun</span>.prototype);  let result = <span class="hljs-keyword">fun</span>.apply(obj,Array.prototype.slice.call(arguments,<span class="hljs-number">1</span>));  <span class="hljs-keyword">if</span>(typeof result == <span class="hljs-string">&quot;Object&quot;</span> || (typeof result ==<span class="hljs-string">&quot;Function&quot;</span> &amp;&amp; result !==<span class="hljs-literal">null</span>))&#123;    <span class="hljs-keyword">return</span> result  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">return</span> obj;  &#125;&#125;</code></pre><h2 id="11、手写Object-create方法"><a href="#11、手写Object-create方法" class="headerlink" title="11、手写Object.create方法"></a>11、手写Object.create方法</h2><p>要实现create方法，我们需要知道create有哪些属性</p><p>Object.create(proto,ptopertiesObject)</p><ul><li>使用指定的proto对象和属性创建一个新的对象</li><li>ptopertiesObject表示给新创建的对象的属性进行设置</li><li>如果ptopertiesObject是null或者不是对象，就会抛出异常</li></ul></li></ul><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.create = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proto,propertiesObject</span>)</span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> propertiesObject !== <span class="hljs-string">&quot;object&quot;</span>)&#123;  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TypeError</span>();  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">temp</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;  <span class="hljs-comment">//挂上原型链</span>  temp.prototype = proto;  <span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> temp();  <span class="hljs-keyword">if</span>(propertiesObject !== <span class="hljs-literal">undefined</span>)&#123;  <span class="hljs-keyword">if</span>(propertiesObject!==<span class="hljs-built_in">Object</span>(propertiesObject))&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TypeError</span>();    &#125;    <span class="hljs-built_in">Object</span>.defineProperties(o,propertiesObject);  &#125;  <span class="hljs-keyword">return</span> o;&#125;</code></pre><h2 id="12、手写Promise方法"><a href="#12、手写Promise方法" class="headerlink" title="12、手写Promise方法"></a>12、手写Promise方法</h2><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">exector</span>)</span> &#123;      <span class="hljs-built_in">this</span>.status = MyPromise.PENDING;      <span class="hljs-comment">// 1.3 “value” is any legal JavaScript value (including undefined, a thenable, or a promise).</span>      <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">null</span>;      <span class="hljs-comment">// 1.5 “reason” is a value that indicates why a promise was rejected.</span>      <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">null</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">       * 2.2.6 then may be called multiple times on the same promise</span><span class="hljs-comment">       *  2.2.6.1 If/when promise is fulfilled, all respective onFulfilled callbacks must execute in the order of their originating calls to then</span><span class="hljs-comment">       *  2.2.6.2 If/when promise is rejected, all respective onRejected callbacks must execute in the order of their originating calls to then.</span><span class="hljs-comment">       */</span>        <span class="hljs-built_in">this</span>.onFulfilledCallback = [];      <span class="hljs-built_in">this</span>.onRejectedCallback = [];      <span class="hljs-built_in">this</span>.initBind();      <span class="hljs-built_in">this</span>.init(exector);    &#125;    <span class="hljs-function"><span class="hljs-title">initBind</span>(<span class="hljs-params"></span>)</span> &#123;      <span class="hljs-comment">// 绑定 this</span>      <span class="hljs-comment">// 因为 resolve 和 reject 会在 exector 作用域中执行，因此这里需要将 this 绑定到当前的实例</span>      <span class="hljs-built_in">this</span>.resolve = <span class="hljs-built_in">this</span>.resolve.bind(<span class="hljs-built_in">this</span>);      <span class="hljs-built_in">this</span>.reject = <span class="hljs-built_in">this</span>.reject.bind(<span class="hljs-built_in">this</span>);    &#125;    <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">exector</span>)</span> &#123;      <span class="hljs-keyword">try</span> &#123;        exector(<span class="hljs-built_in">this</span>.resolve, <span class="hljs-built_in">this</span>.reject);      &#125; <span class="hljs-keyword">catch</span> (err) &#123;        <span class="hljs-built_in">this</span>.reject(err);      &#125;    &#125;      <span class="hljs-function"><span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>)</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === MyPromise.PENDING) &#123;        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-built_in">this</span>.status = MyPromise.FULFILLED;          <span class="hljs-built_in">this</span>.value = value;          <span class="hljs-built_in">this</span>.onFulfilledCallback.forEach(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(<span class="hljs-built_in">this</span>.value));        &#125;)      &#125;    &#125;      <span class="hljs-function"><span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>)</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === MyPromise.PENDING) &#123;        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-built_in">this</span>.status = MyPromise.REJECTED;          <span class="hljs-built_in">this</span>.reason = reason;          <span class="hljs-built_in">this</span>.onRejectedCallback.forEach(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(<span class="hljs-built_in">this</span>.reason));        &#125;)      &#125;    &#125;      <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>)</span> &#123;      onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value      onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> reason &#125;      <span class="hljs-keyword">let</span> promise2;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === MyPromise.FULFILLED) &#123;        <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-keyword">try</span>&#123;              <span class="hljs-keyword">const</span> x = onFulfilled(<span class="hljs-built_in">this</span>.value);              MyPromise.resolvePromise(promise2,x,resolve,reject);            &#125;<span class="hljs-keyword">catch</span>(e)&#123;              reject(e)            &#125;          &#125;)        &#125;)      &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === MyPromise.REJECTED) &#123;        <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-keyword">try</span>&#123;              <span class="hljs-keyword">const</span> x = onRejected(<span class="hljs-built_in">this</span>.reason)              MyPromise.resolvePromise(promise2,x,resolve,reject)            &#125;<span class="hljs-keyword">catch</span>(e)&#123;              reject(e)            &#125;          &#125;)        &#125;)      &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === MyPromise.PENDING) &#123;        <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;          <span class="hljs-comment">// 向对了中装入 onFulfilled 和 onRejected 函数</span>          <span class="hljs-built_in">this</span>.onFulfilledCallback.push(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;            <span class="hljs-keyword">try</span>&#123;              <span class="hljs-keyword">const</span> x = onFulfilled(value)              MyPromise.resolvePromise(promise2,x,resolve,reject)            &#125;<span class="hljs-keyword">catch</span>(e)&#123;              reject(e)            &#125;          &#125;)            <span class="hljs-built_in">this</span>.onRejectedCallback.push(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;            <span class="hljs-keyword">try</span>&#123;              <span class="hljs-keyword">const</span> x = onRejected(reason)              MyPromise.resolvePromise(promise2,x,resolve,reject)            &#125;<span class="hljs-keyword">catch</span>(e)&#123;              reject(e)            &#125;          &#125;)        &#125;)      &#125;    &#125;  &#125;    <span class="hljs-comment">// 2.1 A promise must be in one of three states: pending, fulfilled, or rejected.</span>  MyPromise.PENDING = <span class="hljs-string">&quot;pending&quot;</span>  MyPromise.FULFILLED = <span class="hljs-string">&quot;fulfilled&quot;</span>  MyPromise.REJECTED = <span class="hljs-string">&quot;rejected&quot;</span>    MyPromise.resolvePromise = <span class="hljs-function">(<span class="hljs-params">promise2,x,resolve,reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 2.3.1 If promise and x refer to the same object, reject promise with a TypeError as the reason.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">if</span>(promise2 === x)&#123;      <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;cannot return the same promise object from onfulfilled or on rejected callback.&quot;</span>))    &#125;        <span class="hljs-keyword">if</span>(x <span class="hljs-keyword">instanceof</span> MyPromise)&#123;      <span class="hljs-comment">// 处理返回值是 Promise 对象的情况</span>      <span class="hljs-comment">/**</span><span class="hljs-comment">       * new MyPromise(resolve =&gt; &#123;</span><span class="hljs-comment">       *  resolve(&quot;Success&quot;)</span><span class="hljs-comment">       * &#125;).then(data =&gt; &#123;</span><span class="hljs-comment">       *  return new MyPromise(resolve =&gt; &#123;</span><span class="hljs-comment">       *    resolve(&quot;Success2&quot;)</span><span class="hljs-comment">       *  &#125;)</span><span class="hljs-comment">       * &#125;)</span><span class="hljs-comment">       */</span>      <span class="hljs-keyword">if</span>(x.status === MyPromise.PENDING)&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 2.3.2.1 If x is pending, promise must remain pending until x is fulfilled or rejected.</span><span class="hljs-comment">         */</span>        x.then(<span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> &#123;          <span class="hljs-comment">// 用 x 的 fulfilled 后的 value 值 y，去设置 promise2 的状态</span>          <span class="hljs-comment">// 上面的注视，展示了返回 Promise 对象的情况，这里调用 then 方法的原因</span>          <span class="hljs-comment">// 就是通过参数 y 或者 reason，获取到 x 中的 value/reason</span>            <span class="hljs-comment">// 拿到 y 的值后，使用 y 的值来改变 promise2 的状态</span>          <span class="hljs-comment">// 依照上例，上面生成的 Promise 对象，其 value 应该是 Success2</span>            <span class="hljs-comment">// 这个 y 值，也有可能是新的 Promise，因此要递归的进行解析，例如下面这种情况</span>            <span class="hljs-comment">/**</span><span class="hljs-comment">           * new Promise(resolve =&gt; &#123;</span><span class="hljs-comment">           *  resolve(&quot;Success&quot;)</span><span class="hljs-comment">           * &#125;).then(data =&gt; &#123;</span><span class="hljs-comment">           *  return new Promise(resolve =&gt; &#123;</span><span class="hljs-comment">           *    resolve(new Promise(resolve =&gt; &#123;</span><span class="hljs-comment">           *      resolve(&quot;Success3&quot;)</span><span class="hljs-comment">           *    &#125;))</span><span class="hljs-comment">           *  &#125;)</span><span class="hljs-comment">           * &#125;).then(data =&gt; console.log(data))</span><span class="hljs-comment">           */</span>            MyPromise.resolvePromise(promise2, y, resolve, reject)        &#125;,<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;          reject(reason)        &#125;)      &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 2.3 If x is a thenable, it attempts to make promise adopt the state of x, </span><span class="hljs-comment">         * under the assumption that x behaves at least somewhat like a promise. </span><span class="hljs-comment">         * </span><span class="hljs-comment">         * 2.3.2 If x is a promise, adopt its state [3.4]:</span><span class="hljs-comment">         * 2.3.2.2 If/when x is fulfilled, fulfill promise with the same value.</span><span class="hljs-comment">         * 2.3.2.4 If/when x is rejected, reject promise with the same reason.</span><span class="hljs-comment">         */</span>        x.then(resolve,reject)      &#125;      <span class="hljs-comment">/**</span><span class="hljs-comment">       * 2.3.3 Otherwise, if x is an object or function,</span><span class="hljs-comment">       */</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((x !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span>) || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;function&quot;</span>)&#123;      <span class="hljs-comment">/**</span><span class="hljs-comment">       * 2.3.3.1 Let then be x.then. </span><span class="hljs-comment">       * 2.3.3.2 If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.</span><span class="hljs-comment">       */</span>      <span class="hljs-keyword">try</span>&#123;        <span class="hljs-comment">// then 方法可能设置了访问限制（setter），因此这里进行了错误捕获处理</span>        <span class="hljs-keyword">const</span> then = x.then;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>)&#123;            <span class="hljs-comment">/**</span><span class="hljs-comment">           * 2.3.3.2 If retrieving the property x.then results in a thrown exception e, </span><span class="hljs-comment">           * reject promise with e as the reason.</span><span class="hljs-comment">           */</span>            <span class="hljs-comment">/**</span><span class="hljs-comment">           * 2.3.3.3.1 If/when resolvePromise is called with a value y, run [[Resolve]](promise, y).</span><span class="hljs-comment">           * 2.3.3.3.2 If/when rejectPromise is called with a reason r, reject promise with r.</span><span class="hljs-comment">           */</span>                    then.call(x,<span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> &#123;            <span class="hljs-comment">/**</span><span class="hljs-comment">             * If both resolvePromise and rejectPromise are called, </span><span class="hljs-comment">             * or multiple calls to the same argument are made, </span><span class="hljs-comment">             * the first call takes precedence, and any further calls are ignored.</span><span class="hljs-comment">             */</span>            <span class="hljs-keyword">if</span>(called) <span class="hljs-keyword">return</span>;            called = <span class="hljs-literal">true</span>;            MyPromise.resolvePromise(promise2, y, resolve, reject)                    &#125;,<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;            <span class="hljs-keyword">if</span>(called) <span class="hljs-keyword">return</span>;            called = <span class="hljs-literal">true</span>;            reject(r);          &#125;)        &#125;<span class="hljs-keyword">else</span>&#123;          resolve(x)        &#125;      &#125;<span class="hljs-keyword">catch</span>(e)&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 2.3.3.3.4 If calling then throws an exception e,</span><span class="hljs-comment">         * 2.3.3.3.4.1 If resolvePromise or rejectPromise have been called, ignore it.</span><span class="hljs-comment">         * 2.3.3.3.4.2 Otherwise, reject promise with e as the reason.</span><span class="hljs-comment">         */</span>          <span class="hljs-keyword">if</span>(called) <span class="hljs-keyword">return</span>;        called = <span class="hljs-literal">true</span>;        reject(e)      &#125;    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// If x is not an object or function, fulfill promise with x.</span>      resolve(x);    &#125;  &#125;    MyPromise.deferred  = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> defer = &#123;&#125;    defer.promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      defer.resolve = resolve      defer.reject = reject    &#125;)    <span class="hljs-keyword">return</span> defer  &#125;    <span class="hljs-keyword">try</span> &#123;    <span class="hljs-built_in">module</span>.exports = MyPromise  &#125; <span class="hljs-keyword">catch</span> (e) &#123;  &#125;</code></pre><h1 id="13、setInterval"><a href="#13、setInterval" class="headerlink" title="13、setInterval"></a>13、setInterval</h1><ul><li>setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式</li><li>setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。</li><li>由 setInterval() 返回的 ID 值可用作clearInterval()方法的参数。</li></ul><p>&emsp;&emsp;要实现这个函数，可以通过setTimeout()来实现，我们也可以修改实现的效果，比如说按照叠加的周期进行输出。实现过程很简单：</p><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span>在外面定义一个timer标记我们的定时器，到时候可以关掉let timer = <span class="hljs-literal">null</span>;function mySetInterVal(fn, a, b) &#123;    <span class="hljs-keyword">return</span> &#123;        start: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                fn();                timer ? mySetInterVal(fn, a, b + b).start() : <span class="hljs-literal">null</span>;            &#125;, a + b)        &#125;,        end: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            <span class="hljs-built_in">clearTimeout</span>(timer);            timer = <span class="hljs-literal">null</span>;        &#125;    &#125;&#125;mySetInterVal(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>),<span class="hljs-number">500</span>,<span class="hljs-number">500</span>&#125;).start();          <span class="hljs-regexp">//</span>开始mySetInterVal(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>),<span class="hljs-number">500</span>,<span class="hljs-number">500</span>&#125;).end();                <span class="hljs-regexp">//</span>结束</code></pre>]]></content>
    
    
    <categories>
      
      <category>手写</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
